import{defineComponent as o,toRef as Fr,watch as l,inject as X,provide as Dr,onUnmounted as Ur,createApp as Hr}from"vue";import{Vector3 as Z,Raycaster as Wr,Plane as Xr,Vector2 as I,InstancedMesh as ue,WebGLRenderer as Kr,OrthographicCamera as Vr,PerspectiveCamera as qr,Scene as Zr,Color as se,Texture as Yr,Group as Jr,WebGLCubeRenderTarget as Qr,RGBFormat as es,LinearMipmapLinearFilter as we,CubeCamera as ts,Mesh as rs,BoxGeometry as Ce,CircleGeometry as ss,ConeGeometry as is,CylinderGeometry as ns,DodecahedronGeometry as as,IcosahedronGeometry as os,LatheGeometry as hs,OctahedronGeometry as ds,PlaneGeometry as Me,PolyhedronGeometry as ls,RingGeometry as us,SphereGeometry as cs,TetrahedronGeometry as ms,TorusGeometry as fs,TorusKnotGeometry as ps,TubeGeometry as ys,Curve as gs,CatmullRomCurve3 as Le,SpotLight as ce,DirectionalLight as me,AmbientLight as vs,HemisphereLight as bs,PointLight as Ss,RectAreaLight as Ps,FrontSide as xs,MeshBasicMaterial as Ne,MeshLambertMaterial as ws,TextureLoader as Y,MeshMatcapMaterial as Cs,MeshPhongMaterial as Ms,MeshStandardMaterial as Ls,MeshPhysicalMaterial as Ns,ShaderMaterial as fe,ShaderChunk as K,UniformsUtils as Ge,ShaderLib as Gs,MeshToonMaterial as _s,UVMapping as js,ClampToEdgeWrapping as _e,LinearFilter as Es,CubeReflectionMapping as ks,CubeTextureLoader as Rs,FontLoader as Os,TextGeometry as $s,DoubleSide as Is,SpriteMaterial as zs,Sprite as Ts}from"three";import{OrbitControls as As}from"three/examples/jsm/controls/OrbitControls.js";import{RectAreaLightUniformsLib as Bs}from"three/examples/jsm/lights/RectAreaLightUniformsLib.js";import{RectAreaLightHelper as Fs}from"three/examples/jsm/helpers/RectAreaLightHelper.js";import{GLTFLoader as Ds}from"three/examples/jsm/loaders/GLTFLoader.js";import{FBXLoader as Us}from"three/examples/jsm/loaders/FBXLoader.js";import{EffectComposer as Hs}from"three/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass as Ws}from"three/examples/jsm/postprocessing/RenderPass.js";import{BokehPass as Xs}from"three/examples/jsm/postprocessing/BokehPass.js";import{FilmPass as Ks}from"three/examples/jsm/postprocessing/FilmPass.js";import{ShaderPass as ie}from"three/examples/jsm/postprocessing/ShaderPass.js";import{FXAAShader as Vs}from"three/examples/jsm/shaders/FXAAShader.js";import{HalftonePass as qs}from"three/examples/jsm/postprocessing/HalftonePass.js";import{SMAAPass as Zs}from"three/examples/jsm/postprocessing/SMAAPass.js";import{SSAOPass as Ys}from"three/examples/jsm/postprocessing/SSAOPass.js";import{UnrealBloomPass as Js}from"three/examples/jsm/postprocessing/UnrealBloomPass.js";function Qs(e){const{camera:t,resetPosition:r=new Z(0,0,0)}=e,s=new Wr,n=r.clone(),a=new Xr(new Z(0,0,1),0);return{position:n,updatePosition:P=>{s.setFromCamera(P,t),t.getWorldDirection(a.normal),s.ray.intersectPlane(a,n)},intersect:(P,R)=>(s.setFromCamera(P,t),s.intersectObjects(R))}}function je(e){const{camera:t,domElement:r,intersectObjects:s,touch:n=!0,resetOnEnd:a=!1,resetPosition:i=new I(0,0),resetPositionV3:c=new Z(0,0,0),onEnter:P=()=>{},onMove:R=()=>{},onLeave:f=()=>{},onClick:T=()=>{},onIntersectEnter:W=()=>{},onIntersectOver:x=()=>{},onIntersectMove:F=()=>{},onIntersectLeave:D=()=>{},onIntersectClick:G=()=>{}}=e,m=i.clone(),p=new I(0,0),h=Qs({camera:t}),d=h.position,w={position:m,positionN:p,positionV3:d,intersectObjects:s,listeners:!1,addListeners:Ar,removeListeners:Br,intersect:be};return w;function C(){m.copy(i),d.copy(c)}function de(y){let O,$;y instanceof TouchEvent&&y.touches&&y.touches.length>0?(O=y.touches[0].clientX,$=y.touches[0].clientY):(O=y.clientX,$=y.clientY);const g=r.getBoundingClientRect();m.x=O-g.left,m.y=$-g.top,p.x=m.x/g.width*2-1,p.y=-(m.y/g.height)*2+1,h.updatePosition(p)}function be(){if(s.length){const y=h.intersect(p,s),O=[...s],$=[];y.forEach(g=>{var A,_,M;const{object:S}=g,{component:L}=S.userData;if(S instanceof ue){if($.indexOf(S)!==-1)return;$.push(S)}if(!S.userData.over){S.userData.over=!0;const le={type:"pointerover",over:!0,component:L,intersect:g},xe={...le,type:"pointerenter"};x(le),W(xe),(A=L.onPointerOver)==null||A.call(L,le),(_=L.onPointerEnter)==null||_.call(L,xe)}const Pe={type:"pointermove",component:L,intersect:g};F(Pe),(M=L.onPointerMove)==null||M.call(L,Pe),O.splice(O.indexOf(S),1)}),O.forEach(g=>{var A,_;const{component:M}=g.userData;if(g.userData.over){g.userData.over=!1;const S={type:"pointerover",over:!1,component:M},L={...S,type:"pointerleave"};x(S),D(L),(A=M.onPointerOver)==null||A.call(M,S),(_=M.onPointerLeave)==null||_.call(M,L)}})}}function ee(y){de(y),P({type:"pointerenter",position:m,positionN:p,positionV3:d})}function te(y){de(y),R({type:"pointermove",position:m,positionN:p,positionV3:d}),be()}function Se(y){if(de(y),s.length){const O=h.intersect(p,s),$=[];O.forEach(g=>{var A;const{object:_}=g,{component:M}=_.userData;if(_ instanceof ue){if($.indexOf(_)!==-1)return;$.push(_)}const S={type:"click",component:M,intersect:g};G(S),(A=M.onClick)==null||A.call(M,S)})}T({type:"click",position:m,positionN:p,positionV3:d})}function re(){a&&C(),f({type:"pointerleave"})}function Ar(){r.addEventListener("mouseenter",ee),r.addEventListener("mousemove",te),r.addEventListener("mouseleave",re),r.addEventListener("click",Se),n&&(r.addEventListener("touchstart",ee),r.addEventListener("touchmove",te),r.addEventListener("touchend",re)),w.listeners=!0}function Br(){r.removeEventListener("mouseenter",ee),r.removeEventListener("mousemove",te),r.removeEventListener("mouseleave",re),r.removeEventListener("click",Se),r.removeEventListener("touchstart",ee),r.removeEventListener("touchmove",te),r.removeEventListener("touchend",re),w.listeners=!1}}function ei(e){const t={antialias:!0,alpha:!1,autoClear:!0,orbitCtrl:!1,pointer:!1,resize:!1,width:300,height:150};e&&Object.entries(e).forEach(([h,d])=>{t[h]=d});const r={width:1,height:1,wWidth:1,wHeight:1,ratio:1},s=[],n=[],a=c(),i={config:t,renderer:a,size:r,init:P,dispose:D,render:T,renderC:W,setSize:m,addIntersectObject:x,removeIntersectObject:F};return i;function c(){const h=new Kr({canvas:t.canvas,antialias:t.antialias,alpha:t.alpha});return h.autoClear=t.autoClear,h}function P(){if(!i.scene)return console.error("Missing Scene"),!1;if(!i.camera)return console.error("Missing Camera"),!1;if(t.resize?(G(),window.addEventListener("resize",G)):t.width&&t.height&&m(t.width,t.height),R(),t.orbitCtrl){const h=new As(i.camera,i.renderer.domElement);t.orbitCtrl instanceof Object&&Object.entries(t.orbitCtrl).forEach(([d,w])=>{h[d]=w}),f(()=>{h.update()}),i.cameraCtrl=h}return!0}function R(){let h={camera:i.camera,domElement:i.renderer.domElement,intersectObjects:n};t.pointer&&t.pointer instanceof Object&&(h={...h,...t.pointer});const d=i.pointer=je(h);(t.pointer||n.length)&&(d.addListeners(),h.intersectMode==="frame"&&f(d.intersect))}function f(h){s.push(h)}function T(){s.forEach(h=>h()),i.renderer.render(i.scene,i.camera)}function W(){s.forEach(h=>h()),i.composer.render()}function x(h){n.indexOf(h)===-1&&n.push(h),i.pointer&&!i.pointer.listeners&&i.pointer.addListeners()}function F(h){const d=n.indexOf(h);d!==-1&&n.splice(d,1),i.pointer&&!t.pointer&&n.length===0&&i.pointer.removeListeners()}function D(){window.removeEventListener("resize",G),i.pointer&&i.pointer.removeListeners(),i.cameraCtrl&&i.cameraCtrl.dispose(),i.renderer&&i.renderer.dispose()}function G(){var h;if(t.resize==="window")m(window.innerWidth,window.innerHeight);else{const d=i.renderer.domElement.parentNode;d&&m(d.clientWidth,d.clientHeight)}(h=t.onResize)==null||h.call(t,r)}function m(h,d){r.width=h,r.height=d,r.ratio=h/d,i.renderer.setSize(h,d,!1);const w=i.camera;if(w.type==="PerspectiveCamera"){const C=w;C.aspect=r.ratio,C.updateProjectionMatrix()}if(w.type==="OrthographicCamera"){const C=w;r.wWidth=C.right-C.left,r.wHeight=C.top-C.bottom}else{const C=p();r.wWidth=C[0],r.wHeight=C[1]}}function p(){const h=i.camera,d=h.fov*Math.PI/180,w=2*Math.tan(d/2)*Math.abs(h.position.z);return[w*h.aspect,w]}}const N=Symbol("Renderer");var Ee=o({name:"Renderer",props:{antialias:Boolean,alpha:Boolean,autoClear:{type:Boolean,default:!0},orbitCtrl:{type:[Boolean,Object],default:!1},pointer:{type:[Boolean,Object],default:!1},resize:{type:[Boolean,String],default:!1},shadow:Boolean,width:String,height:String,xr:Boolean,onReady:Function,onClick:Function},setup(e){const t=[],r=[],s=[],n=[],a=[],i=document.createElement("canvas"),c={canvas:i,antialias:e.antialias,alpha:e.alpha,autoClear:e.autoClear,orbitCtrl:e.orbitCtrl,pointer:e.pointer,resize:e.resize};e.width&&(c.width=parseInt(e.width)),e.height&&(c.height=parseInt(e.height));const P=ei(c),R=()=>{};return e.onClick&&i.addEventListener("click",e.onClick),{canvas:i,three:P,renderer:P.renderer,size:P.size,renderFn:R,raf:!0,initCallbacks:t,mountedCallbacks:r,beforeRenderCallbacks:s,afterRenderCallbacks:n,resizeCallbacks:a}},computed:{camera:{get:function(){return this.three.camera},set:function(e){this.three.camera=e}},scene:{get:function(){return this.three.scene},set:function(e){this.three.scene=e}},composer:{get:function(){return this.three.composer},set:function(e){this.three.composer=e}}},provide(){return{[N]:this}},mounted(){var e;this.$el.parentNode.insertBefore(this.canvas,this.$el),this.three.init()&&(this.three.config.onResize=t=>{this.resizeCallbacks.forEach(r=>r({type:"resize",renderer:this,size:t}))},this.renderer.shadowMap.enabled=this.shadow,this.renderFn=this.three.composer?this.three.renderC:this.three.render,this.initCallbacks.forEach(t=>t({type:"init",renderer:this})),(e=this.onReady)==null||e.call(this,this),this.xr?(this.renderer.xr.enabled=!0,this.renderer.setAnimationLoop(this.render)):requestAnimationFrame(this.renderLoop)),this.mountedCallbacks.forEach(t=>t({type:"mounted",renderer:this}))},beforeUnmount(){this.canvas.remove(),this.beforeRenderCallbacks=[],this.afterRenderCallbacks=[],this.raf=!1,this.three.dispose()},methods:{onInit(e){this.addListener("init",e)},onMounted(e){this.addListener("mounted",e)},onBeforeRender(e){this.addListener("beforerender",e)},offBeforeRender(e){this.removeListener("beforerender",e)},onAfterRender(e){this.addListener("afterrender",e)},offAfterRender(e){this.removeListener("afterrender",e)},onResize(e){this.addListener("resize",e)},offResize(e){this.removeListener("resize",e)},addListener(e,t){this.getCallbacks(e).push(t)},removeListener(e,t){const r=this.getCallbacks(e),s=r.indexOf(t);s&&r.splice(s,1)},getCallbacks(e){return e==="init"?this.initCallbacks:e==="mounted"?this.mountedCallbacks:e==="beforerender"?this.beforeRenderCallbacks:e==="afterrender"?this.afterRenderCallbacks:this.resizeCallbacks},render(e){this.beforeRenderCallbacks.forEach(t=>t({type:"beforerender",renderer:this,time:e})),this.renderFn(),this.afterRenderCallbacks.forEach(t=>t({type:"afterrender",renderer:this,time:e}))},renderLoop(e){this.raf&&requestAnimationFrame(this.renderLoop),this.render(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Renderer"});function V(e,t){t instanceof Object&&Object.entries(t).forEach(([r,s])=>{e[r]=s})}function U(e,t,r){t.forEach(s=>{u(e,s,r,s)})}function u(e,t,r,s){const n=s||t,a=Fr(e,t);a.value instanceof Object?(V(r[n],a.value),l(a,i=>{V(r[n],i)},{deep:!0})):(a.value&&(r[n]=e[t]),l(a,i=>{r[n]=i}))}function z(e,t=[]){const r={};return Object.entries(e).forEach(([s,n])=>{(!t||t&&!t.includes(s))&&(r[s]=n)}),r}function ke(e,t,r){return r=r<0?0:r,r=r>1?1:r,e+(t-e)*r}function Re(e,t,r){return e<t?t:e>r?r:e}const ti="https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d",ri="0404E8_0404B5_0404CB_3333FC";function pe(e=ri,t=1024){const r=`${e}${si(t)}.png`;return`${ti}/${t}/${r}`}function si(e){switch(e){case 64:return"-64px";case 128:return"-128px";case 256:return"-256px";case 512:return"-512px";default:return""}}var Oe=o({render(){return this.$slots.default?this.$slots.default():[]}}),$e=o({extends:Oe,name:"OrthographicCamera",props:{left:{type:Number,default:-1},right:{type:Number,default:1},top:{type:Number,default:1},bottom:{type:Number,default:-1},near:{type:Number,default:.1},far:{type:Number,default:2e3},zoom:{type:Number,default:1},position:{type:Object,default:()=>({x:0,y:0,z:0})}},setup(e){const t=X(N);if(!t){console.error("Renderer not found");return}const r=new Vr(e.left,e.right,e.top,e.bottom,e.near,e.far);return t.camera=r,u(e,"position",r),["left","right","top","bottom","near","far","zoom"].forEach(n=>{l(()=>e[n],a=>{r[n]=a,r.updateProjectionMatrix()})}),{renderer:t,camera:r}},__hmrId:"OrthographicCamera"}),ne=o({extends:Oe,name:"PerspectiveCamera",props:{aspect:{type:Number,default:1},far:{type:Number,default:2e3},fov:{type:Number,default:50},near:{type:Number,default:.1},position:{type:Object,default:()=>({x:0,y:0,z:0})},lookAt:{type:Object,default:null}},setup(e){var t;const r=X(N);if(!r){console.error("Renderer not found");return}const s=new qr(e.fov,e.aspect,e.near,e.far);return r.camera=s,u(e,"position",s),e.lookAt&&s.lookAt((t=e.lookAt.x)!=null?t:0,e.lookAt.y,e.lookAt.z),l(()=>e.lookAt,a=>{var i;s.lookAt((i=a.x)!=null?i:0,a.y,a.z)},{deep:!0}),["aspect","far","fov","near"].forEach(a=>{l(()=>e[a],i=>{s[a]=i,s.updateProjectionMatrix()})}),{renderer:r,camera:s}},__hmrId:"PerspectiveCamera"});const ae=Symbol("Scene");var Ie=o({name:"Scene",props:{background:[String,Number,Object]},setup(e){const t=X(N),r=new Zr;if(!t){console.error("Renderer not found");return}t.scene=r,Dr(ae,r);const s=i=>{!i||(typeof i=="string"||typeof i=="number"?r.background instanceof se?r.background.set(i):r.background=new se(i):i instanceof Yr&&(r.background=i))};return s(e.background),l(()=>e.background,s),{scene:r,add:i=>{r.add(i)},remove:i=>{r.remove(i)}}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Scene"}),B=o({name:"Object3D",inject:{renderer:N,scene:ae},emits:["created","ready"],props:{position:{type:Object,default:()=>({x:0,y:0,z:0})},rotation:{type:Object,default:()=>({x:0,y:0,z:0})},scale:{type:Object,default:()=>({x:1,y:1,z:1,order:"XYZ"})},lookAt:{type:Object,default:null},autoRemove:{type:Boolean,default:!0},userData:{type:Object,default:()=>({})}},setup(){return{}},created(){this.renderer||console.error("Missing parent Renderer"),this.scene||console.error("Missing parent Scene")},unmounted(){this.autoRemove&&this.removeFromParent()},methods:{initObject3D(e){var t;this.o3d=e,this.$emit("created",e),u(this,"position",e),u(this,"rotation",e),u(this,"scale",e),u(this,"userData",e.userData),this.lookAt&&e.lookAt((t=this.lookAt.x)!=null?t:0,this.lookAt.y,this.lookAt.z),l(()=>this.lookAt,r=>{var s;e.lookAt((s=r.x)!=null?s:0,r.y,r.z)},{deep:!0}),this.parent=this.getParent(),this.addToParent()?this.$emit("ready",this):console.error("Missing parent (Scene, Group...)")},getParent(){let e=this.$parent;for(;e;){if(e.add)return e;e=e.$parent}},addToParent(e){const t=e||this.o3d;return this.parent?(this.parent.add(t),!0):!1},removeFromParent(e){const t=e||this.o3d;return this.parent?(this.parent.remove(t),!0):!1},add(e){var t;(t=this.o3d)==null||t.add(e)},remove(e){var t;(t=this.o3d)==null||t.remove(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Object3D"}),ze=o({name:"Group",extends:B,setup(){return{group:new Jr}},created(){this.initObject3D(this.group)},__hmrId:"Group"});const J=()=>{};var Te=o({name:"Raycaster",props:{onPointerEnter:{type:Function,default:J},onPointerOver:{type:Function,default:J},onPointerMove:{type:Function,default:J},onPointerLeave:{type:Function,default:J},onClick:{type:Function,default:J},intersectMode:{type:String,default:"move"}},setup(){return{renderer:X(N)}},mounted(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer;this.renderer.onMounted(()=>{!e.camera||(this.pointer=je({camera:e.camera,domElement:e.canvas,intersectObjects:this.getIntersectObjects(),onIntersectEnter:this.onPointerEnter,onIntersectOver:this.onPointerOver,onIntersectMove:this.onPointerMove,onIntersectLeave:this.onPointerLeave,onIntersectClick:this.onClick}),this.pointer.addListeners(),this.intersectMode==="frame"&&e.onBeforeRender(this.pointer.intersect))})},unmounted(){var e;this.pointer&&(this.pointer.removeListeners(),(e=this.renderer)==null||e.offBeforeRender(this.pointer.intersect))},methods:{getIntersectObjects(){return this.renderer&&this.renderer.scene?this.renderer.scene.children.filter(t=>["Mesh","InstancedMesh"].includes(t.type)):[]}},render(){return[]},__hmrId:"Raycaster"}),Ae=o({extends:B,props:{cubeRTSize:{type:Number,default:256},cubeCameraNear:{type:Number,default:.1},cubeCameraFar:{type:Number,default:2e3},autoUpdate:Boolean},setup(e){const t=X(N);if(!t||!t.scene){console.error("Missing Renderer / Scene");return}const r=t.renderer,s=t.scene,n=new Qr(e.cubeRTSize,{format:es,generateMipmaps:!0,minFilter:we}),a=new ts(e.cubeCameraNear,e.cubeCameraFar,n),i=()=>{a.update(r,s)};return e.autoUpdate?(t.onBeforeRender(i),Ur(()=>{t.offBeforeRender(i)})):t.onMounted(i),{cubeRT:n,cubeCamera:a}},render(){return[]},__hmrId:"CubeCamera"});const ii={onPointerEnter:Function,onPointerOver:Function,onPointerMove:Function,onPointerLeave:Function,onPointerDown:Function,onPointerUp:Function,onClick:Function},Q=Symbol("Mesh"),H=o({name:"Mesh",extends:B,props:{castShadow:Boolean,receiveShadow:Boolean,...ii},setup(){return{}},provide(){return{[Q]:this}},mounted(){!this.mesh&&!this.loading&&this.initMesh()},methods:{initMesh(){const e=new rs(this.geometry,this.material);e.userData.component=this,u(this,"castShadow",e),u(this,"receiveShadow",e),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer&&this.renderer.three.addIntersectObject(e),this.mesh=e,this.initObject3D(e)},createGeometry(){},addGeometryWatchers(e){Object.keys(e).forEach(t=>{l(()=>this[t],()=>{this.refreshGeometry()})})},setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.mesh&&this.geometry&&(this.mesh.geometry=this.geometry),e==null||e.dispose()}},unmounted(){this.mesh&&this.renderer&&this.renderer.three.removeIntersectObject(this.mesh),this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose()},__hmrId:"Mesh"});function v(e,t,r){return o({name:e,extends:H,props:t,created(){this.createGeometry(),this.addGeometryWatchers(t)},methods:{createGeometry(){this.geometry=r(this)}}})}const Be=o({props:{rotateX:Number,rotateY:Number,rotateZ:Number},inject:{mesh:Q},setup(){return{}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh.setGeometry(this.geometry),Object.keys(this.$props).forEach(e=>{l(()=>this[e],this.refreshGeometry)})},unmounted(){var e;(e=this.geometry)==null||e.dispose()},methods:{createGeometry(){},rotateGeometry(){!this.geometry||(this.rotateX&&this.geometry.rotateX(this.rotateX),this.rotateY&&this.geometry.rotateY(this.rotateY),this.rotateZ&&this.geometry.rotateZ(this.rotateZ))},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh&&this.mesh.setGeometry(this.geometry),e==null||e.dispose()}},render(){return[]}});function b(e,t,r){return o({name:e,extends:Be,props:t,methods:{createGeometry(){this.geometry=r(this)}}})}const Fe={size:Number,width:{type:Number,default:1},height:{type:Number,default:1},depth:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},depthSegments:{type:Number,default:1}};function De(e){return e.size?new Ce(e.size,e.size,e.size,e.widthSegments,e.heightSegments,e.depthSegments):new Ce(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}var Ue=b("BoxGeometry",Fe,De);const He={radius:{type:Number,default:1},segments:{type:Number,default:8},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function We(e){return new ss(e.radius,e.segments,e.thetaStart,e.thetaLength)}var Xe=b("CircleGeometry",He,We);const Ke={radius:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Ve(e){return new is(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var qe=b("ConeGeometry",Ke,Ve);const Ze={radiusTop:{type:Number,default:1},radiusBottom:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Ye(e){return new ns(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var Je=b("CylinderGeometry",Ze,Ye);const Qe={radius:{type:Number,default:1},detail:{type:Number,default:0}};function et(e){return new as(e.radius,e.detail)}var tt=b("DodecahedronGeometry",Qe,et);const rt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function st(e){return new os(e.radius,e.detail)}var it=b("IcosahedronGeometry",rt,st);const nt={points:Array,segments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:Math.PI*2}};function at(e){return new hs(e.points,e.segments,e.phiStart,e.phiLength)}var ot=b("LatheGeometry",nt,at);const ht={radius:{type:Number,default:1},detail:{type:Number,default:0}};function dt(e){return new ds(e.radius,e.detail)}var lt=b("OctahedronGeometry",ht,dt);const ut={width:{type:Number,default:1},height:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1}};function ct(e){return new Me(e.width,e.height,e.widthSegments,e.heightSegments)}var mt=b("PlaneGeometry",ut,ct);const ft={vertices:Array,indices:Array,radius:{type:Number,default:1},detail:{type:Number,default:0}};function pt(e){return new ls(e.vertices,e.indices,e.radius,e.detail)}var yt=b("PolyhedronGeometry",ft,pt);const gt={innerRadius:{type:Number,default:.5},outerRadius:{type:Number,default:1},thetaSegments:{type:Number,default:8},phiSegments:{type:Number,default:1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function vt(e){return new us(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}var bt=b("RingGeometry",gt,vt);const St={radius:{type:Number,default:1},widthSegments:{type:Number,default:12},heightSegments:{type:Number,default:12}};function Pt(e){return new cs(e.radius,e.widthSegments,e.heightSegments)}var xt=b("SphereGeometry",St,Pt);const wt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function Ct(e){return new ms(e.radius,e.detail)}var Mt=b("TetrahedronGeometry",wt,Ct);const Lt={radius:{type:Number,default:1},tube:{type:Number,default:.4},radialSegments:{type:Number,default:8},tubularSegments:{type:Number,default:6},arc:{type:Number,default:Math.PI*2}};function Nt(e){return new fs(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}var Gt=b("TorusGeometry",Lt,Nt);const _t={radius:{type:Number,default:1},tube:{type:Number,default:.4},tubularSegments:{type:Number,default:64},radialSegments:{type:Number,default:8},p:{type:Number,default:2},q:{type:Number,default:3}};function jt(e){return new ps(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}var Et=b("TorusKnotGeometry",_t,jt);const ye={points:Array,path:gs,tubularSegments:{type:Number,default:64},radius:{type:Number,default:1},radialSegments:{type:Number,default:8},closed:{type:Boolean,default:!1}};function kt(e){let t;return e.points?t=new Le(e.points):e.path?t=e.path:console.error("Missing path curve or points."),new ys(t,e.tubularSegments,e.radius,e.radiusSegments,e.closed)}var Rt=o({extends:Be,props:ye,methods:{createGeometry(){this.geometry=kt(this)},updatePoints(e){Ot(this.geometry,e)}}});function Ot(e,t){const r=new Le(t),{radialSegments:s,radius:n,tubularSegments:a,closed:i}=e.parameters,c=r.computeFrenetFrames(a,i);e.tangents=c.tangents,e.normals=c.normals,e.binormals=c.binormals,e.parameters.path=r;const P=e.getAttribute("position"),R=e.getAttribute("normal"),f=new Z,T=new Z;for(let x=0;x<a;x++)W(x);W(a),e.attributes.position.needsUpdate=!0,e.attributes.normal.needsUpdate=!0;function W(x){r.getPointAt(x/a,T);const F=c.normals[x],D=c.binormals[x];for(let G=0;G<=s;G++){const m=G/s*Math.PI*2,p=Math.sin(m),h=-Math.cos(m);f.x=h*F.x+p*D.x,f.y=h*F.y+p*D.y,f.z=h*F.z+p*D.z,f.normalize();const d=x*(s+1)+G;R.setXYZ(d,f.x,f.y,f.z),P.setXYZ(d,T.x+n*f.x,T.y+n*f.y,T.z+n*f.z)}}}var q=o({extends:B,name:"Light",props:{color:{type:String,default:"#ffffff"},intensity:{type:Number,default:1},castShadow:{type:Boolean,default:!1},shadowMapSize:{type:Object,default:()=>({x:512,y:512})},shadowCamera:{type:Object,default:()=>({})}},setup(){return{}},unmounted(){(this.light instanceof ce||this.light instanceof me)&&this.removeFromParent(this.light.target)},methods:{initLight(e){this.light=e,e.shadow&&(e.castShadow=this.castShadow,V(e.shadow.mapSize,this.shadowMapSize),V(e.shadow.camera,this.shadowCamera)),["color","intensity","castShadow"].forEach(t=>{l(()=>this[t],r=>{t==="color"?e.color.set(r):e[t]=r})}),this.initObject3D(e),(e instanceof ce||e instanceof me)&&(u(this,"target",e.target,"position"),this.addToParent(e.target))}},__hmrId:"Light"}),$t=o({extends:q,created(){this.initLight(new vs(this.color,this.intensity))},__hmrId:"AmbientLight"}),It=o({extends:q,props:{target:{type:Object,default:()=>({x:0,y:0,z:0})}},created(){this.initLight(new me(this.color,this.intensity))},__hmrId:"DirectionalLight"}),zt=o({extends:q,props:{groundColor:{type:String,default:"#444444"}},created(){const e=new bs(this.color,this.groundColor,this.intensity);l(()=>this.groundColor,t=>{e.groundColor.set(t)}),this.initLight(e)},__hmrId:"HemisphereLight"}),Tt=o({extends:q,props:{distance:{type:Number,default:0},decay:{type:Number,default:1}},created(){this.initLight(new Ss(this.color,this.intensity,this.distance,this.decay))},__hmrId:"PointLight"}),At=o({extends:q,props:{width:{type:Number,default:10},height:{type:Number,default:10},helper:Boolean},created(){Bs.init();const e=new Ps(this.color,this.intensity,this.width,this.height);if(["width","height"].forEach(r=>{l(()=>this[r],s=>{e[r]=s})}),this.helper){const r=new Fs(e);e.add(r)}this.initLight(e)},__hmrId:"RectAreaLight"}),Bt=o({extends:q,props:{angle:{type:Number,default:Math.PI/3},decay:{type:Number,default:1},distance:{type:Number,default:0},penumbra:{type:Number,default:0},target:Object},created(){const e=new ce(this.color,this.intensity,this.distance,this.angle,this.penumbra,this.decay);["angle","decay","distance","penumbra"].forEach(r=>{l(()=>this[r],s=>{e[r]=s})}),this.initLight(e)},__hmrId:"SpotLight"});const oe=Symbol("Material");var j=o({inject:{mesh:Q},props:{color:{type:[String,Number],default:"#ffffff"},depthTest:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!0},fog:{type:Boolean,default:!0},opacity:{type:Number,default:1},side:{type:Number,default:xs},transparent:Boolean,vertexColors:Boolean},setup(){return{}},provide(){return{[oe]:this}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}this.createMaterial&&(this.material=this.createMaterial(),this.mesh.setMaterial(this.material),this.addWatchers())},unmounted(){var e;(e=this.material)==null||e.dispose()},methods:{setProp(e,t,r=!1){this.material&&(this.material[e]=t,this.material.needsUpdate=r)},setTexture(e,t="map"){this.setProp(t,e,!0)},addWatchers(){["color","depthTest","depthWrite","fog","opacity","side","transparent"].forEach(e=>{l(()=>this[e],t=>{e==="color"?this.material.color.set(t):this.material[e]=t})})}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Material"});const E={wireframe:{type:Boolean,default:!1},wireframeLinewidth:{type:Number,default:1}};var Ft=o({extends:j,props:{...E},methods:{createMaterial(){const e=new Ne(z(this.$props));return U(this,Object.keys(E),e),e}},__hmrId:"BasicMaterial"}),Dt=o({extends:j,props:{...E},methods:{createMaterial(){const e=new ws(z(this.$props));return U(this,Object.keys(E),e),e}},__hmrId:"LambertMaterial"}),Ut=o({extends:j,props:{src:String,name:{type:String,default:"0404E8_0404B5_0404CB_3333FC"},flatShading:Boolean},methods:{createMaterial(){const e=this.src?this.src:pe(this.name),t=z(this.$props,["src","name"]);return t.matcap=new Y().load(e),new Cs(t)}},__hmrId:"MatcapMaterial"}),Ht=o({extends:j,props:{emissive:{type:[Number,String],default:0},emissiveIntensity:{type:Number,default:1},reflectivity:{type:Number,default:1},shininess:{type:Number,default:30},specular:{type:[String,Number],default:1118481},flatShading:Boolean,...E},methods:{createMaterial(){const e=new Ms(z(this.$props));return["emissive","emissiveIntensity","reflectivity","shininess","specular"].forEach(r=>{l(()=>this[r],s=>{r==="emissive"||r==="specular"?e[r].set(s):e[r]=s})}),U(this,Object.keys(E),e),e}},__hmrId:"PhongMaterial"});const Wt={aoMapIntensity:{type:Number,default:1},bumpScale:{type:Number,default:1},displacementBias:{type:Number,default:0},displacementScale:{type:Number,default:1},emissive:{type:[String,Number],default:0},emissiveIntensity:{type:Number,default:1},envMapIntensity:{type:Number,default:1},lightMapIntensity:{type:Number,default:1},metalness:{type:Number,default:0},normalScale:{type:Object,default:()=>({x:1,y:1})},roughness:{type:Number,default:1},refractionRatio:{type:Number,default:.98},flatShading:Boolean};var ge=o({extends:j,props:{...Wt,...E},methods:{createMaterial(){const e=new Ls(z(this.$props,["normalScale"]));return Object.keys(Wt).forEach(t=>{t!=="normalScale"&&l(()=>this[t],r=>{t==="emissive"?e[t].set(r):e[t]=r})}),u(this,"normalScale",e),U(this,Object.keys(E),e),e}},__hmrId:"StandardMaterial"}),Xt=o({extends:ge,props:{flatShading:Boolean},methods:{createMaterial(){return new Ns(z(this.$props))}},__hmrId:"PhysicalMaterial"});const ni=`
  varying vec2 vUv;
  void main(){
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
  }
`,ai=`
  varying vec2 vUv;
  void main() {
    gl_FragColor = vec4(vUv.x, vUv.y, 0., 1.0);
  }
`;var Kt=o({extends:j,props:{uniforms:{type:Object,default:()=>({})},vertexShader:{type:String,default:ni},fragmentShader:{type:String,default:ai}},methods:{createMaterial(){const e=new fe({uniforms:this.uniforms,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader});return["vertexShader","fragmentShader"].forEach(r=>{l(()=>this[r],s=>{this.setProp(r,s,!0)})}),e},addWatchers(){}},__hmrId:"ShaderMaterial"});function oi(e,t,r){return e.split(t).join(r)}const hi=K.meshphong_frag.slice(0,K.meshphong_frag.indexOf("void main() {")),di=K.meshphong_frag.slice(K.meshphong_frag.indexOf("void main() {")),li={uniforms:Ge.merge([Gs.phong.uniforms,{thicknessColor:{value:new se(16777215)},thicknessDistortion:{value:.1},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}}]),vertexShader:`
    #define USE_UV
    ${K.meshphong_vert}
  `,fragmentShader:`
    #define USE_UV
    #define SUBSURFACE

    ${hi}

    uniform float thicknessPower;
    uniform float thicknessScale;
    uniform float thicknessDistortion;
    uniform float thicknessAmbient;
    uniform float thicknessAttenuation;
    uniform vec3 thicknessColor;

    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {
      #ifdef USE_COLOR
        vec3 thickness = vColor * thicknessColor;
      #else
        vec3 thickness = thicknessColor;
      #endif
      vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));
      float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
      vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
      reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
    }
  `+di.replace("#include <lights_fragment_begin>",oi(K.lights_fragment_begin,"RE_Direct( directLight, geometry, material, reflectedLight );",`
        RE_Direct( directLight, geometry, material, reflectedLight );
        #if defined( SUBSURFACE ) && defined( USE_UV )
          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);
        #endif
      `))},Vt={color:{type:[String,Number],default:"#ffffff"},thicknessColor:{type:[String,Number],default:"#ffffff"},thicknessDistortion:{type:Number,default:.4},thicknessAmbient:{type:Number,default:.01},thicknessAttenuation:{type:Number,default:.7},thicknessPower:{type:Number,default:2},thicknessScale:{type:Number,default:4}};var qt=o({extends:j,props:Vt,methods:{createMaterial(){const e=li,t=Ge.clone(e.uniforms);return Object.keys(Vt).forEach(s=>{const n=this[s];let a=s,i=n;["color","thicknessColor"].includes(s)&&(s==="color"&&(a="diffuse"),i=new se(n)),t[a].value=i}),new fe({...e,uniforms:t,lights:!0,transparent:this.transparent,vertexColors:this.vertexColors})}},__hmrId:"SubSurfaceMaterial"}),Zt=o({extends:j,props:{...E},methods:{createMaterial(){const e=new _s(z(this.$props));return U(this,Object.keys(E),e),e}},__hmrId:"ToonMaterial"}),ve=o({inject:{material:oe},props:{name:{type:String,default:"map"},uniform:String,src:String,onLoad:Function,onProgress:Function,onError:Function,mapping:{type:Number,default:js},wrapS:{type:Number,default:_e},wrapT:{type:Number,default:_e},magFilter:{type:Number,default:Es},minFilter:{type:Number,default:we},repeat:{type:Object,default:()=>({x:1,y:1})},rotation:{type:Number,default:0},center:{type:Object,default:()=>({x:0,y:0})}},setup(){return{}},created(){this.refreshTexture(),l(()=>this.src,this.refreshTexture)},unmounted(){var e,t;(e=this.material)==null||e.setTexture(null,this.name),(t=this.texture)==null||t.dispose()},methods:{createTexture(){if(!this.src)return;const e=new Y().load(this.src,this.onLoaded,this.onProgress,this.onError);return["mapping","wrapS","wrapT","magFilter","minFilter","repeat","rotation","center"].forEach(r=>{u(this,r,e)}),e},refreshTexture(){this.texture=this.createTexture(),this.texture&&this.material&&(this.material.setTexture(this.texture,this.name),this.material.material instanceof fe&&this.uniform&&(this.material.uniforms[this.uniform]={value:this.texture}))},onLoaded(e){var t;(t=this.onLoad)==null||t.call(this,e)}},render(){return[]}}),Yt=o({extends:ve,props:{path:{type:String,required:!0},urls:{type:Array,default:()=>["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]},mapping:{type:Number,default:ks}},created(){l(()=>this.path,this.refreshTexture),l(()=>this.urls,this.refreshTexture)},methods:{createTexture(){return new Rs().setPath(this.path).load(this.urls,this.onLoaded,this.onProgress,this.onError)}}}),Jt=v("Box",Fe,De),Qt=v("Circle",He,We),er=v("Cone",Ke,Ve),tr=v("Cylinder",Ze,Ye),rr=v("Dodecahedron",Qe,et),sr=v("Icosahedron",rt,st),ir=v("Lathe",nt,at),nr=v("Octahedron",ht,dt),ar=v("Plane",ut,ct),or=v("Polyhedron",ft,pt),hr=v("Ring",gt,vt),dr=v("Sphere",St,Pt),lr=v("Tetrahedron",wt,Ct);const ui={text:{type:String,required:!0,default:"Text"},fontSrc:{type:String,required:!0},size:{type:Number,default:80},height:{type:Number,default:5},depth:{type:Number,default:1},curveSegments:{type:Number,default:12},bevelEnabled:{type:Boolean,default:!1},bevelThickness:{type:Number,default:10},bevelSize:{type:Number,default:8},bevelOffset:{type:Number,default:0},bevelSegments:{type:Number,default:5},align:{type:[Boolean,String],default:!1}};var ur=o({extends:H,props:ui,setup(){return{}},created(){if(!this.fontSrc){console.error('Missing required prop: "font-src"');return}["text","size","height","curveSegments","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","align"].forEach(r=>{l(()=>this[r],()=>{this.font&&this.refreshGeometry()})});const t=new Os;this.loading=!0,t.load(this.fontSrc,r=>{this.loading=!1,this.font=r,this.createGeometry(),this.initMesh()})},methods:{createGeometry(){this.geometry=new $s(this.text,{font:this.font,size:this.size,height:this.height,depth:this.depth,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize,bevelOffset:this.bevelOffset,bevelSegments:this.bevelSegments}),this.align==="center"&&this.geometry.center()}}}),cr=v("Torus",Lt,Nt),mr=v("TorusKnot",_t,jt),fr=o({extends:H,props:ye,created(){this.createGeometry(),this.addGeometryWatchers(ye)},methods:{createGeometry(){this.geometry=kt(this)},updatePoints(e){Ot(this.geometry,e)}},__hmrId:"Tube"}),pr=o({emits:["loaded"],extends:H,props:{src:{type:String,required:!0},width:Number,height:Number,widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},keepSize:Boolean},setup(){return{}},created(){!this.renderer||(this.geometry=new Me(1,1,this.widthSegments,this.heightSegments),this.material=new Ne({side:Is,map:this.loadTexture()}),l(()=>this.src,this.refreshTexture),["width","height"].forEach(e=>{l(()=>this[e],this.resize)}),this.resize(),this.keepSize&&this.renderer.onResize(this.resize))},unmounted(){var e;(e=this.renderer)==null||e.offResize(this.resize)},methods:{loadTexture(){return new Y().load(this.src,this.onLoaded)},refreshTexture(){var e;(e=this.texture)==null||e.dispose(),this.material&&(this.material.map=this.loadTexture(),this.material.needsUpdate=!0)},onLoaded(e){this.texture=e,this.resize(),this.$emit("loaded",e)},resize(){if(!this.renderer||!this.texture)return;const e=this.renderer.size,t=this.texture.image.width,r=this.texture.image.height,s=t/r;let n=1,a=1;this.width&&this.height?(n=this.width*e.wWidth/e.width,a=this.height*e.wHeight/e.height):this.width?(n=this.width*e.wWidth/e.width,a=n/s):this.height?(a=this.height*e.wHeight/e.height,n=a*s):s>1?n=a*s:a=n/s,this.mesh&&(this.mesh.scale.x=n,this.mesh.scale.y=a)}},__hmrId:"Image"}),yr=o({extends:H,props:{count:{type:Number,required:!0}},methods:{initMesh(){if(!!this.renderer){if(!this.geometry||!this.material)return console.error("Missing geometry and/or material"),!1;this.mesh=new ue(this.geometry,this.material,this.count),this.mesh.userData.component=this,u(this,"castShadow",this.mesh),u(this,"receiveShadow",this.mesh),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer.three.addIntersectObject(this.mesh),this.initObject3D(this.mesh)}}},__hmrId:"InstancedMesh"}),gr=o({extends:B,emits:["loaded"],props:{src:{type:String,required:!0}},setup(){return{}},created(){this.texture=new Y().load(this.src,this.onLoaded),this.material=new zs({map:this.texture}),this.sprite=new Ts(this.material),this.initObject3D(this.sprite)},unmounted(){var e,t;(e=this.texture)==null||e.dispose(),(t=this.material)==null||t.dispose()},methods:{onLoaded(){this.updateUV(),this.$emit("loaded")},updateUV(){if(!this.texture||!this.sprite)return;const e=this.texture.image.width,t=this.texture.image.height,r=e/t;let s=.5,n=.5;r>1?s=.5*r:n=.5/r;const a=this.sprite.geometry.attributes.position.array;a[0]=-s,a[1]=-n,a[5]=s,a[6]=-n,a[10]=s,a[11]=n,a[15]=-s,a[16]=n,this.sprite.geometry.attributes.position.needsUpdate=!0}},__hmrId:"Sprite"}),vr=o({extends:B,emits:["load","progress","error"],props:{src:{type:String,required:!0}},data(){return{progress:0}},methods:{onLoad(e){this.$emit("load",e),this.initObject3D(e)},onProgress(e){this.progress=e.loaded/e.total,this.$emit("progress",e)},onError(e){this.$emit("error",e)}}}),br=o({extends:vr,created(){new Ds().load(this.src,t=>{this.onLoad(t.scene)},this.onProgress,this.onError)}}),Sr=o({extends:vr,created(){new Us().load(this.src,t=>{this.onLoad(t)},this.onProgress,this.onError)}});const he=Symbol("Composer");var Pr=o({setup(){return{renderer:X(N)}},provide(){return{[he]:this}},created(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer,t=new Hs(this.renderer.renderer);this.composer=t,this.renderer.composer=t,e.addListener("init",()=>{e.renderer.autoClear=!1,this.resize(),e.addListener("resize",this.resize)})},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{addPass(e){var t;(t=this.composer)==null||t.addPass(e)},removePass(e){var t;(t=this.composer)==null||t.removePass(e)},resize(){this.composer&&this.renderer&&this.composer.setSize(this.renderer.size.width,this.renderer.size.height)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"EffectComposer"}),k=o({inject:{renderer:N,composer:he},emits:["ready"],setup(){return{}},created(){this.composer||console.error("Missing parent EffectComposer"),this.renderer||console.error("Missing parent Renderer")},unmounted(){var e,t,r;this.pass&&((e=this.composer)==null||e.removePass(this.pass),(r=(t=this.pass).dispose)==null||r.call(t))},methods:{initEffectPass(e){var t;this.pass=e,(t=this.composer)==null||t.addPass(e),this.$emit("ready",e)}},render(){return[]},__hmrId:"EffectPass"}),xr=o({extends:k,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new Ws(this.renderer.scene,this.renderer.camera);this.initEffectPass(e)},__hmrId:"RenderPass"});const wr={focus:{type:Number,default:1},aperture:{type:Number,default:.025},maxblur:{type:Number,default:.01}};var Cr=o({extends:k,props:wr,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e={focus:this.focus,aperture:this.aperture,maxblur:this.maxblur,width:this.renderer.size.width,height:this.renderer.size.height},t=new Xs(this.renderer.scene,this.renderer.camera,e);Object.keys(wr).forEach(r=>{l(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"BokehPass"});const Mr={noiseIntensity:{type:Number,default:.5},scanlinesIntensity:{type:Number,default:.05},scanlinesCount:{type:Number,default:4096},grayscale:{type:Number,default:0}};var Lr=o({extends:k,props:Mr,created(){const e=new Ks(this.noiseIntensity,this.scanlinesIntensity,this.scanlinesCount,this.grayscale);Object.keys(Mr).forEach(t=>{l(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"FilmPass"}),Nr=o({extends:k,created(){var e;const t=new ie(Vs);(e=this.renderer)==null||e.addListener("resize",this.resize),this.initEffectPass(t)},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{resize({size:e}){if(this.pass){const{resolution:t}=this.pass.material.uniforms;t.value.x=1/e.width,t.value.y=1/e.height}}},__hmrId:"FXAAPass"});const Gr={shape:{type:Number,default:1},radius:{type:Number,default:4},rotateR:{type:Number,default:Math.PI/12*1},rotateG:{type:Number,default:Math.PI/12*2},rotateB:{type:Number,default:Math.PI/12*3},scatter:{type:Number,default:0}};var _r=o({extends:k,props:Gr,created(){if(!this.renderer)return;const e=new qs(this.renderer.size.width,this.renderer.size.height,{});Object.keys(Gr).forEach(t=>{e.uniforms[t].value=this[t],l(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"HalftonePass"}),jr=o({extends:k,created(){if(!this.renderer)return;const e=new Zs(this.renderer.size.width,this.renderer.size.height);this.initEffectPass(e)},__hmrId:"SMAAPass"}),Er=o({extends:k,props:{options:{type:Object,default:()=>({})}},created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new Ys(this.renderer.scene,this.renderer.camera,this.renderer.size.width,this.renderer.size.height);Object.keys(this.options).forEach(t=>{e[t]=this.options[t]}),this.initEffectPass(e)},__hmrId:"SSAOPass"}),kr={uniforms:{},vertexShader:`
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,fragmentShader:`
    varying vec2 vUv;
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
  `},Rr={uniforms:{tDiffuse:{value:null},blurRadius:{value:0},gradientRadius:{value:0},start:{value:new I},end:{value:new I},delta:{value:new I},texSize:{value:new I}},vertexShader:kr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform float blurRadius;
    uniform float gradientRadius;
    uniform vec2 start;
    uniform vec2 end;
    uniform vec2 delta;
    uniform vec2 texSize;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }

    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;

      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

      vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));
      float radius = smoothstep(0.0, 1.0, abs(dot(vUv * texSize - start, normal)) / gradientRadius) * blurRadius;
      for (float t = -30.0; t <= 30.0; t++) {
          float percent = (t + offset - 0.5) / 30.0;
          float weight = 1.0 - abs(percent);
          vec4 texel = texture2D(tDiffuse, vUv + delta / texSize * percent * radius);
          // vec4 texel2 = texture2D(tDiffuse, vUv + vec2(-delta.y, delta.x) / texSize * percent * radius);

          /* switch to pre-multiplied alpha to correctly blur transparent images */
          texel.rgb *= texel.a;
          // texel2.rgb *= texel2.a;

          color += texel * weight;
          total += 2.0 * weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `};const ci={blurRadius:{type:Number,default:10},gradientRadius:{type:Number,default:100},start:{type:Object,default:()=>({x:0,y:100})},end:{type:Object,default:()=>({x:10,y:100})}};var Or=o({extends:k,props:ci,setup(){return{uniforms1:{},uniforms2:{}}},created(){if(!this.composer)return;this.pass1=new ie(Rr),this.pass2=new ie(Rr);const e=this.uniforms1=this.pass1.uniforms,t=this.uniforms2=this.pass2.uniforms;t.blurRadius=e.blurRadius,t.gradientRadius=e.gradientRadius,t.start=e.start,t.end=e.end,t.texSize=e.texSize,u(this,"blurRadius",e.blurRadius,"value"),u(this,"gradientRadius",e.gradientRadius,"value"),this.updateFocusLine(),["start","end"].forEach(r=>{l(()=>this[r],this.updateFocusLine,{deep:!0})}),this.pass1.setSize=(r,s)=>{e.texSize.value.set(r,s)},this.initEffectPass(this.pass1),this.composer.addPass(this.pass2)},unmounted(){this.composer&&this.pass2&&this.composer.removePass(this.pass2)},methods:{updateFocusLine(){this.uniforms1.start.value.copy(this.start),this.uniforms1.end.value.copy(this.end);const e=new I().copy(this.end).sub(this.start).normalize();this.uniforms1.delta.value.copy(e),this.uniforms2.delta.value.set(-e.y,e.x)}},__hmrId:"TiltShiftPass"});const $r={strength:{type:Number,default:1.5},radius:{type:Number,default:0},threshold:{type:Number,default:0}};var Ir=o({extends:k,props:$r,created(){if(!this.renderer)return;const e=new I(this.renderer.size.width,this.renderer.size.height),t=new Js(e,this.strength,this.radius,this.threshold);Object.keys($r).forEach(r=>{l(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"UnrealBloomPass"}),mi={uniforms:{tDiffuse:{value:null},center:{value:new I(.5,.5)},strength:{value:0}},vertexShader:kr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform vec2 center;
    uniform float strength;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }
    
    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;
      vec2 toCenter = center - vUv;
      
      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
      
      for (float t = 0.0; t <= 40.0; t++) {
        float percent = (t + offset) / 40.0;
        float weight = 4.0 * (percent - percent * percent);
        vec4 texel = texture2D(tDiffuse, vUv + toCenter * percent * strength);

        /* switch to pre-multiplied alpha to correctly blur transparent images */
        texel.rgb *= texel.a;

        color += texel * weight;
        total += weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `},zr=o({extends:k,props:{center:{type:Object,default:()=>({x:.5,y:.5})},strength:{type:Number,default:.5}},created(){const e=new ie(mi);u(this,"center",e.uniforms.center,"value"),u(this,"strength",e.uniforms.strength,"value"),this.initEffectPass(e)},__hmrId:"ZoomBlurPass"}),fi=Object.freeze({__proto__:null,Renderer:Ee,RendererInjectionKey:N,OrthographicCamera:$e,PerspectiveCamera:ne,Camera:ne,Group:ze,Scene:Ie,SceneInjectionKey:ae,Object3D:B,Raycaster:Te,CubeCamera:Ae,BoxGeometry:Ue,CircleGeometry:Xe,ConeGeometry:qe,CylinderGeometry:Je,DodecahedronGeometry:tt,IcosahedronGeometry:it,LatheGeometry:ot,OctahedronGeometry:lt,PlaneGeometry:mt,PolyhedronGeometry:yt,RingGeometry:bt,SphereGeometry:xt,TetrahedronGeometry:Mt,TorusGeometry:Gt,TorusKnotGeometry:Et,TubeGeometry:Rt,AmbientLight:$t,DirectionalLight:It,HemisphereLight:zt,PointLight:Tt,RectAreaLight:At,SpotLight:Bt,Material:j,MaterialInjectionKey:oe,BasicMaterial:Ft,LambertMaterial:Dt,MatcapMaterial:Ut,PhongMaterial:Ht,PhysicalMaterial:Xt,ShaderMaterial:Kt,StandardMaterial:ge,SubSurfaceMaterial:qt,ToonMaterial:Zt,Texture:ve,CubeTexture:Yt,Mesh:H,MeshInjectionKey:Q,Box:Jt,Circle:Qt,Cone:er,Cylinder:tr,Dodecahedron:rr,Icosahedron:sr,Lathe:ir,Octahedron:nr,Plane:ar,Polyhedron:or,Ring:hr,Sphere:dr,Tetrahedron:lr,Text:ur,Torus:cr,TorusKnot:mr,Tube:fr,Image:pr,InstancedMesh:yr,Sprite:gr,GLTFModel:br,FBXModel:Sr,EffectComposer:Pr,ComposerInjectionKey:he,RenderPass:xr,BokehPass:Cr,FilmPass:Lr,FXAAPass:Nr,HalftonePass:_r,SMAAPass:jr,SSAOPass:Er,TiltShiftPass:Or,UnrealBloomPass:Ir,ZoomBlurPass:zr,setFromProp:V,bindProps:U,bindProp:u,propsValues:z,lerp:ke,limit:Re,getMatcapUrl:pe});const Tr={install(e){["Camera","OrthographicCamera","PerspectiveCamera","Raycaster","Renderer","Scene","Group","AmbientLight","DirectionalLight","HemisphereLight","PointLight","RectAreaLight","SpotLight","BasicMaterial","LambertMaterial","MatcapMaterial","PhongMaterial","PhysicalMaterial","ShaderMaterial","StandardMaterial","SubSurfaceMaterial","ToonMaterial","Texture","CubeTexture","Mesh","Box","BoxGeometry","Circle","CircleGeometry","Cone","ConeGeometry","Cylinder","CylinderGeometry","Dodecahedron","DodecahedronGeometry","Icosahedron","IcosahedronGeometry","Lathe","LatheGeometry","Octahedron","OctahedronGeometry","Plane","PlaneGeometry","Polyhedron","PolyhedronGeometry","Ring","RingGeometry","Sphere","SphereGeometry","Tetrahedron","TetrahedronGeometry","Text","Torus","TorusGeometry","TorusKnot","TorusKnotGeometry","Tube","TubeGeometry","Image","InstancedMesh","Sprite","FBXModel","GLTFModel","BokehPass","EffectComposer","FilmPass","FXAAPass","HalftonePass","RenderPass","SAOPass","SMAAPass","SSAOPass","TiltShiftPass","UnrealBloomPass","ZoomBlurPass","GLTFViewer"].forEach(r=>{e.component(r,fi[r])})}};function pi(e){return Hr(e).use(Tr)}function yi(){const e={loader:new Y,count:0,textures:[],loadProgress:0,loadTextures:t,dispose:s};return e;function t(n,a){e.count=n.length,e.textures.splice(0),e.loadProgress=0,Promise.all(n.map(r)).then(a)}function r(n,a){return new Promise(i=>{e.loader.load(n.src,c=>{e.loadProgress+=1/e.count,e.textures[a]=c,i(c)})})}function s(){e.textures.forEach(n=>n.dispose())}}export{$t as AmbientLight,Ft as BasicMaterial,Cr as BokehPass,Jt as Box,Ue as BoxGeometry,ne as Camera,Qt as Circle,Xe as CircleGeometry,he as ComposerInjectionKey,er as Cone,qe as ConeGeometry,Ae as CubeCamera,Yt as CubeTexture,tr as Cylinder,Je as CylinderGeometry,It as DirectionalLight,rr as Dodecahedron,tt as DodecahedronGeometry,Pr as EffectComposer,Sr as FBXModel,Nr as FXAAPass,Lr as FilmPass,br as GLTFModel,ze as Group,_r as HalftonePass,zt as HemisphereLight,sr as Icosahedron,it as IcosahedronGeometry,pr as Image,yr as InstancedMesh,Dt as LambertMaterial,ir as Lathe,ot as LatheGeometry,Ut as MatcapMaterial,j as Material,oe as MaterialInjectionKey,H as Mesh,Q as MeshInjectionKey,B as Object3D,nr as Octahedron,lt as OctahedronGeometry,$e as OrthographicCamera,ne as PerspectiveCamera,Ht as PhongMaterial,Xt as PhysicalMaterial,ar as Plane,mt as PlaneGeometry,Tt as PointLight,or as Polyhedron,yt as PolyhedronGeometry,Te as Raycaster,At as RectAreaLight,xr as RenderPass,Ee as Renderer,N as RendererInjectionKey,hr as Ring,bt as RingGeometry,jr as SMAAPass,Er as SSAOPass,Ie as Scene,ae as SceneInjectionKey,Kt as ShaderMaterial,dr as Sphere,xt as SphereGeometry,Bt as SpotLight,gr as Sprite,ge as StandardMaterial,qt as SubSurfaceMaterial,lr as Tetrahedron,Mt as TetrahedronGeometry,ur as Text,ve as Texture,Or as TiltShiftPass,Zt as ToonMaterial,cr as Torus,Gt as TorusGeometry,mr as TorusKnot,Et as TorusKnotGeometry,Tr as TroisJSVuePlugin,fr as Tube,Rt as TubeGeometry,Ir as UnrealBloomPass,zr as ZoomBlurPass,u as bindProp,U as bindProps,pi as createApp,pe as getMatcapUrl,ke as lerp,Re as limit,z as propsValues,V as setFromProp,yi as useTextures};
//# sourceMappingURL=trois.module.min.js.map
