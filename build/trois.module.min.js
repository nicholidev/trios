import{h as e}from"vue";import{Vector2 as t,Vector3 as s,Plane as i,Raycaster as r,WebGLRenderer as n,PerspectiveCamera as o,Scene as a,Color as h,BoxBufferGeometry as u,SphereBufferGeometry as c,AmbientLight as d,PointLight as m,SpotLight as l,FrontSide as f,MeshBasicMaterial as p,MeshLambertMaterial as g,MeshPhongMaterial as w,MeshPhysicalMaterial as y,MeshStandardMaterial as b,Mesh as v,PlaneBufferGeometry as S,InstancedMesh as N}from"three";import{OrbitControls as z}from"three/examples/jsm/controls/OrbitControls.js";import{EffectComposer as j}from"three/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass as x}from"three/examples/jsm/postprocessing/RenderPass.js";import{BokehPass as _}from"three/examples/jsm/postprocessing/BokehPass.js";import{UnrealBloomPass as C}from"three/examples/jsm/postprocessing/UnrealBloomPass.js";function M(){var e={canvas:null,antialias:!0,alpha:!1,orbit_ctrl:!1,mouse_move:!1,mouse_raycast:!1,resize:"window",width:0,height:0},o={width:0,height:0,wWidth:0,wHeight:0,ratio:0},a=[],h=[],u=[],c=new t,d=new s,m=new i(new s(0,0,1),0),l=new r,f={conf:e,renderer:null,camera:null,cameraCtrl:null,materials:{},scene:null,size:o,mouse:c,mouseV3:d,init:function(t){if(t)for(var[s,i]of Object.entries(t))e[s]=i;if(!f.scene)return void console.error("Missing Scene");if(!f.camera)return void console.error("Missing Camera");if(f.renderer=new n({canvas:e.canvas,antialias:e.antialias,alpha:e.alpha}),e.orbit_ctrl&&(f.orbitCtrl=new z(f.camera,f.renderer.domElement),e.orbit_ctrl instanceof Object))for(var[r,o]of Object.entries(e.orbit_ctrl))f.orbitCtrl[r]=o;e.width&&e.height?b(e.width,e.height):e.resize&&(y(),window.addEventListener("resize",y));e.mouse_move&&("body"===e.mouse_move?f.mouse_move_element=document.body:f.mouse_move_element=f.renderer.domElement,f.mouse_move_element.addEventListener("mousemove",p),f.mouse_move_element.addEventListener("mouseleave",g));return a.forEach((function(e){return e()})),!0},dispose:function(){window.removeEventListener("resize",y),f.mouse_move_element&&(f.mouse_move_element.removeEventListener("mousemove",p),f.mouse_move_element.removeEventListener("mouseleave",g))},render:function(){f.orbitCtrl&&f.orbitCtrl.update();u.forEach((function(e){return e()})),f.renderer.render(f.scene,f.camera)},renderC:function(){f.orbitCtrl&&f.orbitCtrl.update();u.forEach((function(e){return e()})),f.composer.render()},setSize:b,onAfterInit:function(e){a.push(e)},onAfterResize:function(e){h.push(e)},onBeforeRender:function(e){u.push(e)}};function p(e){c.x=e.clientX/o.width*2-1,c.y=-e.clientY/o.height*2+1,w()}function g(e){c.x=0,c.y=0,w()}function w(){e.mouse_raycast&&(f.camera.getWorldDirection(m.normal),m.normal.normalize(),l.setFromCamera(c,f.camera),l.ray.intersectPlane(m,d))}function y(){"window"===e.resize?b(window.innerWidth,window.innerHeight):b(e.resize.clientWidth,e.resize.clientHeight),h.forEach((function(e){return e()}))}function b(e,t){o.width=e,o.height=t,o.ratio=e/t,f.renderer.setSize(e,t,!1),f.camera.aspect=o.ratio,f.camera.updateProjectionMatrix(),f.composer&&f.composer.setSize(e,t);var s=function(){var e=f.camera.fov*Math.PI/180,t=2*Math.tan(e/2)*Math.abs(f.camera.position.z);return[t*f.camera.aspect,t]}();o.wWidth=s[0],o.wHeight=s[1]}return f}var B={props:{antialias:{type:Boolean,default:!0},alpha:{type:Boolean,default:!1},shadow:{type:Boolean,default:!1},orbitCtrl:{type:[Boolean,Object],default:!1},mouseMove:{type:[Boolean,String],default:!1},mouseRaycast:{type:Boolean,default:!1},resize:{type:[Boolean,String,Element],default:"window"},width:String,height:String},setup:function(e){return{three:M(),raf:!0}},provide:function(){return{three:this.three}},mounted:function(){var e={canvas:this.$refs.canvas,antialias:this.antialias,alpha:this.alpha,orbit_ctrl:this.orbitCtrl,mouse_move:this.mouseMove,mouse_raycast:this.mouseRaycast,resize:this.resize,width:this.width,height:this.height};this.three.init(e)&&(this.three.renderer.shadowMap.enabled=this.shadow,this.three.composer?this.animateC():this.animate())},beforeUnmount:function(){this.raf=!1,this.three.dispose()},methods:{onBeforeRender:function(e){this.three.onBeforeRender(e)},onAfterResize:function(e){this.three.onAfterResize(e)},animate:function(){this.raf&&requestAnimationFrame(this.animate),this.three.render()},animateC:function(){this.raf&&requestAnimationFrame(this.animateC),this.three.renderC()}},render:function(){return e("canvas",{ref:"canvas"},this.$slots.default())}};function E(e,t){if(t instanceof Object)for(var[s,i]of Object.entries(t))e[s]=i}function O(e,t,s){return e+(t-e)*(s=(s=s<0?0:s)>1?1:s)}function P(e,t,s){e.x=O(e.x,t.x,s),e.y=O(e.y,t.y,s),e.z=O(e.z,t.z,s)}var R={inject:["three"],props:{fov:{type:Number,default:50},position:Object},created:function(){var e=new o(this.fov);E(e.position,this.position),this.three.camera=e},render:function(){return[]}},L={inject:["three"],props:{id:String,background:[String,Number]},setup:function(e){var t=new a;return e.background&&(t.background=new h(e.background)),{scene:t}},provide:function(){return{scene:this.scene}},mounted:function(){this.three.scene||(this.three.scene=this.scene)},render:function(){return this.$slots.default?this.$slots.default():[]}},A={inject:["parent"],beforeMount:function(){this.parent||console.error("Missing parent Mesh")},unmounted:function(){this.parent.geometry.dispose()},render:function(){return[]}},$={extends:A,props:{size:{type:Number},width:{type:Number,default:1},height:{type:Number,default:1},depth:{type:Number,default:1}},mounted:function(){this.size?this.parent.geometry=new u(this.size,this.size,this.size):this.parent.geometry=new u(this.width,this.height,this.depth)}},k={extends:A,props:{radius:Number,widthSegments:{type:Number,default:12},heightSegments:{type:Number,default:12}},mounted:function(){this.parent.geometry=new c(this.radius,this.widthSegments,this.heightSegments)}},I={inject:["scene"],props:{color:{type:String,default:"#ffffff"},intensity:{type:Number,default:1},castShadow:{type:Boolean,default:!1},shadowMapSize:Object,position:Object},mounted:function(){E(this.light.position,this.position),this.light.shadow&&(this.light.castShadow=this.castShadow,E(this.light.shadow.mapSize,this.shadowMapSize)),this.scene.add(this.light),this.light.target&&this.scene.add(this.light.target)},render:function(){return[]}},W={extends:I,created:function(){this.light=new d(this.color,this.intensity)}},H={extends:I,props:{distance:{type:Number,default:0},decay:{type:Number,default:1}},created:function(){this.light=new m(this.color,this.intensity,this.distance,this.decay)}},F={extends:I,props:{distance:{type:Number,default:0},angle:{type:Number,default:Math.PI/3},penumbra:{type:Number,default:0},decay:{type:Number,default:1}},created:function(){this.light=new l(this.color,this.intensity,this.distance,this.angle,this.penumbra,this.decay)}},U={inject:["three"],props:{id:String,color:{type:[String,Number],default:"#ffffff"},depthTest:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!0},fog:{type:Boolean,default:!1},opacity:{type:Number,default:1},side:{type:Number,default:f},transparent:{type:Boolean,default:!1},vertexColors:{type:Boolean,default:!1}},mounted:function(){this.three.materials[this.id]=this.material},unmounted:function(){this.material.dispose()},methods:{propsValues:function(){var e={};for(var[t,s]of Object.entries(this.$props))"id"!==t&&(e[t]=s);return e}},render:function(){return[]}},V={extends:U,created:function(){this.material=new p({color:this.color})}},q={extends:U,created:function(){this.material=new g({color:this.color})}},D={extends:U,created:function(){this.material=new w({color:this.color})}},G={extends:U,created:function(){this.material=new y({color:this.color})}},T={extends:U,props:{emissive:{type:[Number,String],default:0},emissiveIntensity:{type:Number,default:1},metalness:{type:Number,default:0},roughness:{type:Number,default:1}},created:function(){this.material=new b(this.propsValues())}},X={inject:["three","scene"],props:{material:String,position:Object,rotation:Object,scale:Object,castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},mounted:function(){this.mesh=new v(this.geometry,this.three.materials[this.material]),E(this.mesh.position,this.position),E(this.mesh.rotation,this.rotation),E(this.mesh.scale,this.scale),this.mesh.castShadow=this.castShadow,this.mesh.receiveShadow=this.receiveShadow,this.scene.add(this.mesh)},unmounted:function(){this.geometry.dispose()},render:function(){return[]}},Y={extends:X,props:{size:{type:Number},width:{type:Number,default:1},height:{type:Number,default:1},depth:{type:Number,default:1}},created:function(){this.size?this.geometry=new u(this.size,this.size,this.size):this.geometry=new u(this.width,this.height,this.depth)}},J={extends:X,props:{width:{type:Number,default:1},height:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1}},created:function(){this.geometry=new S(this.width,this.height,this.widthSegments,this.heightSegments)}},K={extends:X,props:{radius:Number,widthSegments:{type:Number,default:12},heightSegments:{type:Number,default:12}},created:function(){this.geometry=new c(this.radius,this.widthSegments,this.heightSegments)}},Q={inject:["three","scene"],props:{material:String,count:Number,position:Object,castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},setup:function(){return{conf:{}}},provide:function(){return{parent:this.conf}},beforeMount:function(){this.$slots.default||console.error("Missing Geometry")},mounted:function(){this.mesh=new N(this.conf.geometry,this.three.materials[this.material],this.count),E(this.mesh.position,this.position),this.mesh.castShadow=this.castShadow,this.mesh.receiveShadow=this.receiveShadow,this.scene.add(this.mesh)},render:function(){return this.$slots.default()}},Z={setup:function(){return{passes:[]}},inject:["three"],provide:function(){return{passes:this.passes}},mounted:function(){var e=this;this.three.onAfterInit((function(){e.composer=new j(e.three.renderer),e.passes.forEach((function(t){e.composer.addPass(t)})),e.three.composer=e.composer}))},render:function(){return this.$slots.default()}},ee={inject:["three","passes"],beforeMount:function(){this.passes||console.error("Missing parent EffectComposer")},render:function(){return[]}},te={extends:ee,mounted:function(){this.three.scene||console.error("Missing Scene"),this.three.camera||console.error("Missing Camera");var e=new x(this.three.scene,this.three.camera);this.passes.push(e),this.pass=e}},se={extends:ee,props:{focus:{type:Number,default:1},aperture:{type:Number,default:.025},maxblur:{type:Number,default:.01}},mounted:function(){this.three.scene||console.error("Missing Scene"),this.three.camera||console.error("Missing Camera");var e={focus:this.focus,aperture:this.aperture,maxblur:this.maxblur,width:this.three.size.width,height:this.three.size.height},t=new _(this.three.scene,this.three.camera,e);this.passes.push(t),this.pass=t}},ie={extends:ee,props:{strength:{type:Number,default:1.5},radius:{type:Number,default:0},threshold:{type:Number,default:0}},mounted:function(){var e=new t(this.three.size.width,this.three.size.height),s=new C(e,this.strength,this.radius,this.threshold);this.passes.push(s),this.pass=s}};export{W as AmbientLight,V as BasicMaterial,se as BokehPass,Y as Box,$ as BoxGeometry,R as Camera,Z as EffectComposer,Q as InstancedMesh,q as LambertMaterial,R as PerspectiveCamera,D as PhongMaterial,G as PhysicalMaterial,J as Plane,H as PointLight,te as RenderPass,B as Renderer,L as Scene,K as Sphere,k as SphereGeometry,F as SpotLight,T as StandardMaterial,ie as UnrealBloomPass,O as lerp,P as lerpv3,E as setFromProp};
//# sourceMappingURL=trois.module.min.js.map
