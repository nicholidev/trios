import{Vector3 as Y,Raycaster as Ur,Plane as Hr,Vector2 as T,InstancedMesh as ce,WebGLRenderer as Xr,PCFShadowMap as Kr,NoToneMapping as Wr,OrthographicCamera as Vr,PerspectiveCamera as qr,Scene as Zr,Color as se,Texture as Yr,Group as Jr,WebGLCubeRenderTarget as Qr,RGBFormat as es,LinearMipmapLinearFilter as Me,CubeCamera as ts,Mesh as rs,BufferGeometry as ss,BufferAttribute as is,BoxGeometry as Ce,CircleGeometry as ns,ConeGeometry as as,CylinderGeometry as os,DodecahedronGeometry as hs,IcosahedronGeometry as ds,LatheGeometry as ls,OctahedronGeometry as us,PlaneGeometry as Le,PolyhedronGeometry as cs,RingGeometry as ms,SphereGeometry as fs,TetrahedronGeometry as ps,TorusGeometry as ys,TorusKnotGeometry as gs,TubeGeometry as vs,Curve as bs,CatmullRomCurve3 as Ne,SpotLight as me,DirectionalLight as fe,AmbientLight as Ss,HemisphereLight as Ps,PointLight as ws,RectAreaLight as xs,NormalBlending as Ms,FrontSide as Cs,MeshBasicMaterial as Ge,MeshLambertMaterial as Ls,TextureLoader as J,MeshMatcapMaterial as Ns,MeshPhongMaterial as Gs,MeshStandardMaterial as _s,MeshPhysicalMaterial as js,ShaderMaterial as pe,ShaderChunk as K,UniformsUtils as _e,ShaderLib as Es,MeshToonMaterial as Os,LinearEncoding as ks,UVMapping as Rs,ClampToEdgeWrapping as je,LinearFilter as $s,CubeReflectionMapping as zs,CubeTextureLoader as Ts,PointsMaterial as Is,FontLoader as As,TextGeometry as Bs,DoubleSide as Fs,SpriteMaterial as Ds,Sprite as Us,Points as Hs}from"three";import{toRef as Xs,watch as l,defineComponent as o,inject as W,provide as Ks,onUnmounted as Ws,createApp as Vs}from"vue";import{OrbitControls as qs}from"three/examples/jsm/controls/OrbitControls.js";import{RectAreaLightUniformsLib as Zs}from"three/examples/jsm/lights/RectAreaLightUniformsLib.js";import{RectAreaLightHelper as Ys}from"three/examples/jsm/helpers/RectAreaLightHelper.js";import{GLTFLoader as Js}from"three/examples/jsm/loaders/GLTFLoader.js";import{FBXLoader as Qs}from"three/examples/jsm/loaders/FBXLoader.js";import{EffectComposer as ei}from"three/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass as ti}from"three/examples/jsm/postprocessing/RenderPass.js";import{BokehPass as ri}from"three/examples/jsm/postprocessing/BokehPass.js";import{FilmPass as si}from"three/examples/jsm/postprocessing/FilmPass.js";import{ShaderPass as ie}from"three/examples/jsm/postprocessing/ShaderPass.js";import{FXAAShader as ii}from"three/examples/jsm/shaders/FXAAShader.js";import{HalftonePass as ni}from"three/examples/jsm/postprocessing/HalftonePass.js";import{SMAAPass as ai}from"three/examples/jsm/postprocessing/SMAAPass.js";import{SSAOPass as oi}from"three/examples/jsm/postprocessing/SSAOPass.js";import{UnrealBloomPass as hi}from"three/examples/jsm/postprocessing/UnrealBloomPass.js";function V(e,t){t instanceof Object&&Object.entries(t).forEach(([r,s])=>{e[r]=s})}function U(e,t,r){t.forEach(s=>{u(e,s,r,s)})}function u(e,t,r,s){const n=s||t,a=Xs(e,t);a.value instanceof Object?(V(r[n],a.value),l(a,i=>{V(r[n],i)},{deep:!0})):(a.value!==void 0&&(r[n]=e[t]),l(a,i=>{r[n]=i}))}function N(e,t=[]){const r={};return Object.entries(e).forEach(([s,n])=>{(!t||t&&!t.includes(s))&&(r[s]=n)}),r}function Ee(e,t,r){return r=r<0?0:r,r=r>1?1:r,e+(t-e)*r}function Oe(e,t,r){return e<t?t:e>r?r:e}const di="https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d",li="0404E8_0404B5_0404CB_3333FC";function ye(e=li,t=1024){const r=`${e}${ui(t)}.png`;return`${di}/${t}/${r}`}function ui(e){switch(e){case 64:return"-64px";case 128:return"-128px";case 256:return"-256px";case 512:return"-512px";default:return""}}function ci(e){const{camera:t,resetPosition:r=new Y(0,0,0)}=e,s=new Ur,n=r.clone(),a=new Hr(new Y(0,0,1),0);return{position:n,updatePosition:b=>{s.setFromCamera(b,t),t.getWorldDirection(a.normal),s.ray.intersectPlane(a,n)},intersect:(b,R)=>(s.setFromCamera(b,t),s.intersectObjects(R))}}function ke(e){const{camera:t,domElement:r,intersectObjects:s,touch:n=!0,resetOnEnd:a=!1,resetPosition:i=new T(0,0),resetPositionV3:c=new Y(0,0,0),onEnter:b=()=>{},onMove:R=()=>{},onLeave:f=()=>{},onClick:A=()=>{},onIntersectEnter:X=()=>{},onIntersectOver:w=()=>{},onIntersectMove:F=()=>{},onIntersectLeave:D=()=>{},onIntersectClick:j=()=>{}}=e,m=i.clone(),p=new T(0,0),h=ci({camera:t}),d=h.position,x={position:m,positionN:p,positionV3:d,intersectObjects:s,listeners:!1,addListeners:Fr,removeListeners:Dr,intersect:Se};return x;function M(){m.copy(i),d.copy(c)}function le(S){let $,z;S.touches&&S.touches.length>0?($=S.touches[0].clientX,z=S.touches[0].clientY):($=S.clientX,z=S.clientY);const y=r.getBoundingClientRect();m.x=$-y.left,m.y=z-y.top,p.x=m.x/y.width*2-1,p.y=-(m.y/y.height)*2+1,h.updatePosition(p)}function Se(){if(s.length){const S=h.intersect(p,s),$=[...s],z=[];S.forEach(y=>{var B,E,C;const{object:P}=y,{component:L}=P.userData;if(P instanceof ce){if(z.indexOf(P)!==-1)return;z.push(P)}if(!P.userData.over){P.userData.over=!0;const ue={type:"pointerover",over:!0,component:L,intersect:y},xe={...ue,type:"pointerenter"};w(ue),X(xe),(B=L.onPointerOver)==null||B.call(L,ue),(E=L.onPointerEnter)==null||E.call(L,xe)}const we={type:"pointermove",component:L,intersect:y};F(we),(C=L.onPointerMove)==null||C.call(L,we),$.splice($.indexOf(P),1)}),$.forEach(y=>{var B,E;const{component:C}=y.userData;if(y.userData.over){y.userData.over=!1;const P={type:"pointerover",over:!1,component:C},L={...P,type:"pointerleave"};w(P),D(L),(B=C.onPointerOver)==null||B.call(C,P),(E=C.onPointerLeave)==null||E.call(C,L)}})}}function ee(S){le(S),b({type:"pointerenter",position:m,positionN:p,positionV3:d})}function te(S){le(S),R({type:"pointermove",position:m,positionN:p,positionV3:d}),Se()}function Pe(S){if(le(S),s.length){const $=h.intersect(p,s),z=[];$.forEach(y=>{var B;const{object:E}=y,{component:C}=E.userData;if(E instanceof ce){if(z.indexOf(E)!==-1)return;z.push(E)}const P={type:"click",component:C,intersect:y};j(P),(B=C.onClick)==null||B.call(C,P)})}A({type:"click",position:m,positionN:p,positionV3:d})}function re(){a&&M(),f({type:"pointerleave"})}function Fr(){r.addEventListener("mouseenter",ee),r.addEventListener("mousemove",te),r.addEventListener("mouseleave",re),r.addEventListener("click",Pe),n&&(r.addEventListener("touchstart",ee),r.addEventListener("touchmove",te),r.addEventListener("touchend",re)),x.listeners=!0}function Dr(){r.removeEventListener("mouseenter",ee),r.removeEventListener("mousemove",te),r.removeEventListener("mouseleave",re),r.removeEventListener("click",Pe),r.removeEventListener("touchstart",ee),r.removeEventListener("touchmove",te),r.removeEventListener("touchend",re),x.listeners=!1}}function mi(e){const t={antialias:!0,alpha:!1,autoClear:!0,orbitCtrl:!1,pointer:!1,resize:!1,width:300,height:150};e&&Object.entries(e).forEach(([h,d])=>{t[h]=d});const r={width:1,height:1,wWidth:1,wHeight:1,ratio:1},s=[],n=[],a=c(),i={config:t,renderer:a,size:r,init:b,dispose:D,render:A,renderC:X,setSize:m,addIntersectObject:w,removeIntersectObject:F};return i;function c(){const h=new Xr({canvas:t.canvas,antialias:t.antialias,alpha:t.alpha});return h.autoClear=t.autoClear,h}function b(){if(!i.scene)return console.error("Missing Scene"),!1;if(!i.camera)return console.error("Missing Camera"),!1;if(t.resize?(j(),window.addEventListener("resize",j)):t.width&&t.height&&m(t.width,t.height),R(),t.orbitCtrl){const h=new qs(i.camera,i.renderer.domElement);t.orbitCtrl instanceof Object&&Object.entries(t.orbitCtrl).forEach(([d,x])=>{h[d]=x}),f(()=>{h.update()}),i.cameraCtrl=h}return!0}function R(){let h={camera:i.camera,domElement:i.renderer.domElement,intersectObjects:n};t.pointer&&t.pointer instanceof Object&&(h={...h,...t.pointer});const d=i.pointer=ke(h);(t.pointer||n.length)&&(d.addListeners(),h.intersectMode==="frame"&&f(d.intersect))}function f(h){s.push(h)}function A(){s.forEach(h=>h()),i.renderer.render(i.scene,i.camera)}function X(){s.forEach(h=>h()),i.composer.render()}function w(h){n.indexOf(h)===-1&&n.push(h),i.pointer&&!i.pointer.listeners&&i.pointer.addListeners()}function F(h){const d=n.indexOf(h);d!==-1&&n.splice(d,1),i.pointer&&!t.pointer&&n.length===0&&i.pointer.removeListeners()}function D(){window.removeEventListener("resize",j),i.pointer&&i.pointer.removeListeners(),i.cameraCtrl&&i.cameraCtrl.dispose(),i.renderer&&i.renderer.dispose()}function j(){var h;if(t.resize==="window")m(window.innerWidth,window.innerHeight);else{const d=i.renderer.domElement.parentNode;d&&m(d.clientWidth,d.clientHeight)}(h=t.onResize)==null||h.call(t,r)}function m(h,d){r.width=h,r.height=d,r.ratio=h/d,i.renderer.setSize(h,d,!1);const x=i.camera;if(x.type==="PerspectiveCamera"){const M=x;M.aspect=r.ratio,M.updateProjectionMatrix()}if(x.type==="OrthographicCamera"){const M=x;r.wWidth=M.right-M.left,r.wHeight=M.top-M.bottom}else{const M=p();r.wWidth=M[0],r.wHeight=M[1]}}function p(){const h=i.camera,d=h.fov*Math.PI/180,x=2*Math.tan(d/2)*Math.abs(h.position.z);return[x*h.aspect,x]}}const G=Symbol("Renderer");var Re=o({name:"Renderer",props:{antialias:Boolean,alpha:Boolean,autoClear:{type:Boolean,default:!0},orbitCtrl:{type:[Boolean,Object],default:!1},pointer:{type:[Boolean,Object],default:!1},resize:{type:[Boolean,String],default:!1},shadow:Boolean,shadowType:{type:Number,default:Kr},toneMapping:{type:Number,default:Wr},width:String,height:String,xr:Boolean,onReady:Function,onClick:Function},setup(e){const t=[],r=[],s=[],n=[],a=[],i=document.createElement("canvas"),c={canvas:i,antialias:e.antialias,alpha:e.alpha,autoClear:e.autoClear,orbitCtrl:e.orbitCtrl,pointer:e.pointer,resize:e.resize};e.width&&(c.width=parseInt(e.width)),e.height&&(c.height=parseInt(e.height));const b=mi(c);u(e,"toneMapping",b.renderer);const R=()=>{};return e.onClick&&i.addEventListener("click",e.onClick),{canvas:i,three:b,renderer:b.renderer,size:b.size,renderFn:R,raf:!0,initCallbacks:t,mountedCallbacks:r,beforeRenderCallbacks:s,afterRenderCallbacks:n,resizeCallbacks:a}},computed:{camera:{get:function(){return this.three.camera},set:function(e){this.three.camera=e}},scene:{get:function(){return this.three.scene},set:function(e){this.three.scene=e}},composer:{get:function(){return this.three.composer},set:function(e){this.three.composer=e}}},provide(){return{[G]:this}},mounted(){var e;this.$el.parentNode.insertBefore(this.canvas,this.$el),this.three.init()&&(this.three.config.onResize=t=>{this.resizeCallbacks.forEach(r=>r({type:"resize",renderer:this,size:t}))},this.shadow&&(this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=this.shadowType),this.renderFn=this.three.composer?this.three.renderC:this.three.render,this.initCallbacks.forEach(t=>t({type:"init",renderer:this})),(e=this.onReady)==null||e.call(this,this),this.xr?(this.renderer.xr.enabled=!0,this.renderer.setAnimationLoop(this.render)):requestAnimationFrame(this.renderLoop)),this.mountedCallbacks.forEach(t=>t({type:"mounted",renderer:this}))},beforeUnmount(){this.canvas.remove(),this.beforeRenderCallbacks=[],this.afterRenderCallbacks=[],this.raf=!1,this.three.dispose()},methods:{onInit(e){this.addListener("init",e)},onMounted(e){this.addListener("mounted",e)},onBeforeRender(e){this.addListener("beforerender",e)},offBeforeRender(e){this.removeListener("beforerender",e)},onAfterRender(e){this.addListener("afterrender",e)},offAfterRender(e){this.removeListener("afterrender",e)},onResize(e){this.addListener("resize",e)},offResize(e){this.removeListener("resize",e)},addListener(e,t){this.getCallbacks(e).push(t)},removeListener(e,t){const r=this.getCallbacks(e),s=r.indexOf(t);s&&r.splice(s,1)},getCallbacks(e){return e==="init"?this.initCallbacks:e==="mounted"?this.mountedCallbacks:e==="beforerender"?this.beforeRenderCallbacks:e==="afterrender"?this.afterRenderCallbacks:this.resizeCallbacks},render(e){this.beforeRenderCallbacks.forEach(t=>t({type:"beforerender",renderer:this,time:e})),this.renderFn({renderer:this,time:e}),this.afterRenderCallbacks.forEach(t=>t({type:"afterrender",renderer:this,time:e}))},renderLoop(e){this.raf&&requestAnimationFrame(this.renderLoop),this.render(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Renderer"}),$e=o({render(){return this.$slots.default?this.$slots.default():[]}}),ze=o({extends:$e,name:"OrthographicCamera",props:{left:{type:Number,default:-1},right:{type:Number,default:1},top:{type:Number,default:1},bottom:{type:Number,default:-1},near:{type:Number,default:.1},far:{type:Number,default:2e3},zoom:{type:Number,default:1},position:{type:Object,default:()=>({x:0,y:0,z:0})}},setup(e){const t=W(G);if(!t){console.error("Renderer not found");return}const r=new Vr(e.left,e.right,e.top,e.bottom,e.near,e.far);return t.camera=r,u(e,"position",r),["left","right","top","bottom","near","far","zoom"].forEach(n=>{l(()=>e[n],a=>{r[n]=a,r.updateProjectionMatrix()})}),{renderer:t,camera:r}},__hmrId:"OrthographicCamera"}),ne=o({extends:$e,name:"PerspectiveCamera",props:{aspect:{type:Number,default:1},far:{type:Number,default:2e3},fov:{type:Number,default:50},near:{type:Number,default:.1},position:{type:Object,default:()=>({x:0,y:0,z:0})},lookAt:{type:Object,default:null}},setup(e){var t;const r=W(G);if(!r){console.error("Renderer not found");return}const s=new qr(e.fov,e.aspect,e.near,e.far);return r.camera=s,u(e,"position",s),e.lookAt&&s.lookAt((t=e.lookAt.x)!=null?t:0,e.lookAt.y,e.lookAt.z),l(()=>e.lookAt,a=>{var i;s.lookAt((i=a.x)!=null?i:0,a.y,a.z)},{deep:!0}),["aspect","far","fov","near"].forEach(a=>{l(()=>e[a],i=>{s[a]=i,s.updateProjectionMatrix()})}),{renderer:r,camera:s}},__hmrId:"PerspectiveCamera"});const ae=Symbol("Scene");var Te=o({name:"Scene",props:{background:[String,Number,Object]},setup(e){const t=W(G),r=new Zr;if(!t){console.error("Renderer not found");return}t.scene=r,Ks(ae,r);const s=i=>{!i||(typeof i=="string"||typeof i=="number"?r.background instanceof se?r.background.set(i):r.background=new se(i):i instanceof Yr&&(r.background=i))};return s(e.background),l(()=>e.background,s),{scene:r,add:i=>{r.add(i)},remove:i=>{r.remove(i)}}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Scene"}),I=o({name:"Object3D",inject:{renderer:G,scene:ae},emits:["created","ready"],props:{position:{type:Object,default:()=>({x:0,y:0,z:0})},rotation:{type:Object,default:()=>({x:0,y:0,z:0})},scale:{type:Object,default:()=>({x:1,y:1,z:1,order:"XYZ"})},lookAt:{type:Object,default:null},userData:{type:Object,default:()=>({})},visible:{type:Boolean,default:!0},autoRemove:{type:Boolean,default:!0}},setup(){return{}},created(){this.renderer||console.error("Missing parent Renderer"),this.scene||console.error("Missing parent Scene")},unmounted(){this.autoRemove&&this.removeFromParent()},methods:{initObject3D(e){var t;this.o3d=e,this.$emit("created",e),u(this,"position",e),u(this,"rotation",e),u(this,"scale",e),u(this,"userData",e.userData),u(this,"visible",e),this.lookAt&&e.lookAt((t=this.lookAt.x)!=null?t:0,this.lookAt.y,this.lookAt.z),l(()=>this.lookAt,r=>{var s;e.lookAt((s=r.x)!=null?s:0,r.y,r.z)},{deep:!0}),this.parent=this.getParent(),this.addToParent()?this.$emit("ready",this):console.error("Missing parent (Scene, Group...)")},getParent(){let e=this.$parent;for(;e;){if(e.add)return e;e=e.$parent}},addToParent(e){const t=e||this.o3d;return this.parent?(this.parent.add(t),!0):!1},removeFromParent(e){const t=e||this.o3d;return this.parent?(this.parent.remove(t),!0):!1},add(e){var t;(t=this.o3d)==null||t.add(e)},remove(e){var t;(t=this.o3d)==null||t.remove(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Object3D"}),Ie=o({name:"Group",extends:I,setup(){return{group:new Jr}},created(){this.initObject3D(this.group)},__hmrId:"Group"});const Q=()=>{};var Ae=o({name:"Raycaster",props:{onPointerEnter:{type:Function,default:Q},onPointerOver:{type:Function,default:Q},onPointerMove:{type:Function,default:Q},onPointerLeave:{type:Function,default:Q},onClick:{type:Function,default:Q},intersectMode:{type:String,default:"move"}},setup(){return{renderer:W(G)}},mounted(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer;this.renderer.onMounted(()=>{!e.camera||(this.pointer=ke({camera:e.camera,domElement:e.canvas,intersectObjects:this.getIntersectObjects(),onIntersectEnter:this.onPointerEnter,onIntersectOver:this.onPointerOver,onIntersectMove:this.onPointerMove,onIntersectLeave:this.onPointerLeave,onIntersectClick:this.onClick}),this.pointer.addListeners(),this.intersectMode==="frame"&&e.onBeforeRender(this.pointer.intersect))})},unmounted(){var e;this.pointer&&(this.pointer.removeListeners(),(e=this.renderer)==null||e.offBeforeRender(this.pointer.intersect))},methods:{getIntersectObjects(){return this.renderer&&this.renderer.scene?this.renderer.scene.children.filter(t=>["Mesh","InstancedMesh"].includes(t.type)):[]}},render(){return[]},__hmrId:"Raycaster"}),Be=o({extends:I,props:{cubeRTSize:{type:Number,default:256},cubeCameraNear:{type:Number,default:.1},cubeCameraFar:{type:Number,default:2e3},autoUpdate:Boolean,hideMeshes:{type:Array,default:()=>[]}},setup(e){const t=W(G);if(!t||!t.scene)return console.error("Missing Renderer / Scene"),{};const r=t.renderer,s=t.scene,n=new Qr(e.cubeRTSize,{format:es,generateMipmaps:!0,minFilter:Me}),a=new ts(e.cubeCameraNear,e.cubeCameraFar,n),i=()=>{e.hideMeshes.forEach(c=>{c.visible=!1}),a.update(r,s),e.hideMeshes.forEach(c=>{c.visible=!0})};return e.autoUpdate?(t.onBeforeRender(i),Ws(()=>{t.offBeforeRender(i)})):t.onMounted(i),{cubeRT:n,cubeCamera:a,updateRT:i}},created(){this.cubeCamera&&this.initObject3D(this.cubeCamera)},render(){return[]},__hmrId:"CubeCamera"});const fi={onPointerEnter:Function,onPointerOver:Function,onPointerMove:Function,onPointerLeave:Function,onPointerDown:Function,onPointerUp:Function,onClick:Function},q=Symbol("Mesh"),H=o({name:"Mesh",extends:I,props:{castShadow:Boolean,receiveShadow:Boolean,...fi},setup(){return{}},provide(){return{[q]:this}},mounted(){!this.mesh&&!this.loading&&this.initMesh()},methods:{initMesh(){const e=new rs(this.geometry,this.material);e.userData.component=this,u(this,"castShadow",e),u(this,"receiveShadow",e),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer&&this.renderer.three.addIntersectObject(e),this.mesh=e,this.initObject3D(e)},createGeometry(){},addGeometryWatchers(e){Object.keys(e).forEach(t=>{l(()=>this[t],()=>{this.refreshGeometry()})})},setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.mesh&&this.geometry&&(this.mesh.geometry=this.geometry),e==null||e.dispose()}},unmounted(){this.mesh&&this.renderer&&this.renderer.three.removeIntersectObject(this.mesh),this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose()},__hmrId:"Mesh"});function g(e,t,r){return o({name:e,extends:H,props:t,created(){this.createGeometry(),this.addGeometryWatchers(t)},methods:{createGeometry(){this.geometry=r(this)}}})}const oe=o({props:{rotateX:Number,rotateY:Number,rotateZ:Number,attributes:{type:Array,default:()=>[]}},inject:{mesh:q},setup(){return{}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh.setGeometry(this.geometry),Object.keys(this.$props).forEach(e=>{l(()=>this[e],this.refreshGeometry)})},unmounted(){var e;(e=this.geometry)==null||e.dispose()},methods:{createGeometry(){const e={},t=new ss;this.attributes.forEach(r=>{if(r.name&&r.itemSize&&r.array){const s=e[r.name]=new is(r.array,r.itemSize,r.normalized);t.setAttribute(r.name,s)}}),t.computeBoundingBox(),this.geometry=t},rotateGeometry(){!this.geometry||(this.rotateX&&this.geometry.rotateX(this.rotateX),this.rotateY&&this.geometry.rotateY(this.rotateY),this.rotateZ&&this.geometry.rotateZ(this.rotateZ))},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh&&this.mesh.setGeometry(this.geometry),e==null||e.dispose()}},render(){return[]}});function v(e,t,r){return o({name:e,extends:oe,props:t,methods:{createGeometry(){this.geometry=r(this)}}})}const Fe={size:Number,width:{type:Number,default:1},height:{type:Number,default:1},depth:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},depthSegments:{type:Number,default:1}};function De(e){return e.size?new Ce(e.size,e.size,e.size,e.widthSegments,e.heightSegments,e.depthSegments):new Ce(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}var Ue=v("BoxGeometry",Fe,De);const He={radius:{type:Number,default:1},segments:{type:Number,default:8},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Xe(e){return new ns(e.radius,e.segments,e.thetaStart,e.thetaLength)}var Ke=v("CircleGeometry",He,Xe);const We={radius:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Ve(e){return new as(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var qe=v("ConeGeometry",We,Ve);const Ze={radiusTop:{type:Number,default:1},radiusBottom:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Ye(e){return new os(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var Je=v("CylinderGeometry",Ze,Ye);const Qe={radius:{type:Number,default:1},detail:{type:Number,default:0}};function et(e){return new hs(e.radius,e.detail)}var tt=v("DodecahedronGeometry",Qe,et);const rt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function st(e){return new ds(e.radius,e.detail)}var it=v("IcosahedronGeometry",rt,st);const nt={points:Array,segments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:Math.PI*2}};function at(e){return new ls(e.points,e.segments,e.phiStart,e.phiLength)}var ot=v("LatheGeometry",nt,at);const ht={radius:{type:Number,default:1},detail:{type:Number,default:0}};function dt(e){return new us(e.radius,e.detail)}var lt=v("OctahedronGeometry",ht,dt);const ut={width:{type:Number,default:1},height:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1}};function ct(e){return new Le(e.width,e.height,e.widthSegments,e.heightSegments)}var mt=v("PlaneGeometry",ut,ct);const ft={vertices:Array,indices:Array,radius:{type:Number,default:1},detail:{type:Number,default:0}};function pt(e){return new cs(e.vertices,e.indices,e.radius,e.detail)}var yt=v("PolyhedronGeometry",ft,pt);const gt={innerRadius:{type:Number,default:.5},outerRadius:{type:Number,default:1},thetaSegments:{type:Number,default:8},phiSegments:{type:Number,default:1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function vt(e){return new ms(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}var bt=v("RingGeometry",gt,vt);const St={radius:{type:Number,default:1},widthSegments:{type:Number,default:12},heightSegments:{type:Number,default:12}};function Pt(e){return new fs(e.radius,e.widthSegments,e.heightSegments)}var wt=v("SphereGeometry",St,Pt);const xt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function Mt(e){return new ps(e.radius,e.detail)}var Ct=v("TetrahedronGeometry",xt,Mt);const Lt={radius:{type:Number,default:1},tube:{type:Number,default:.4},radialSegments:{type:Number,default:8},tubularSegments:{type:Number,default:6},arc:{type:Number,default:Math.PI*2}};function Nt(e){return new ys(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}var Gt=v("TorusGeometry",Lt,Nt);const _t={radius:{type:Number,default:1},tube:{type:Number,default:.4},tubularSegments:{type:Number,default:64},radialSegments:{type:Number,default:8},p:{type:Number,default:2},q:{type:Number,default:3}};function jt(e){return new gs(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}var Et=v("TorusKnotGeometry",_t,jt);const ge={points:Array,path:bs,tubularSegments:{type:Number,default:64},radius:{type:Number,default:1},radialSegments:{type:Number,default:8},closed:{type:Boolean,default:!1}};function Ot(e){let t;return e.points?t=new Ne(e.points):e.path?t=e.path:console.error("Missing path curve or points."),new vs(t,e.tubularSegments,e.radius,e.radiusSegments,e.closed)}var kt=o({extends:oe,props:ge,methods:{createGeometry(){this.geometry=Ot(this)},updatePoints(e){Rt(this.geometry,e)}}});function Rt(e,t){const r=new Ne(t),{radialSegments:s,radius:n,tubularSegments:a,closed:i}=e.parameters,c=r.computeFrenetFrames(a,i);e.tangents=c.tangents,e.normals=c.normals,e.binormals=c.binormals,e.parameters.path=r;const b=e.getAttribute("position"),R=e.getAttribute("normal"),f=new Y,A=new Y;for(let w=0;w<a;w++)X(w);X(a),e.attributes.position.needsUpdate=!0,e.attributes.normal.needsUpdate=!0;function X(w){r.getPointAt(w/a,A);const F=c.normals[w],D=c.binormals[w];for(let j=0;j<=s;j++){const m=j/s*Math.PI*2,p=Math.sin(m),h=-Math.cos(m);f.x=h*F.x+p*D.x,f.y=h*F.y+p*D.y,f.z=h*F.z+p*D.z,f.normalize();const d=w*(s+1)+j;R.setXYZ(d,f.x,f.y,f.z),b.setXYZ(d,A.x+n*f.x,A.y+n*f.y,A.z+n*f.z)}}}var Z=o({extends:I,name:"Light",props:{color:{type:String,default:"#ffffff"},intensity:{type:Number,default:1},castShadow:{type:Boolean,default:!1},shadowMapSize:{type:Object,default:()=>({x:512,y:512})},shadowCamera:{type:Object,default:()=>({})}},setup(){return{}},unmounted(){(this.light instanceof me||this.light instanceof fe)&&this.removeFromParent(this.light.target)},methods:{initLight(e){this.light=e,e.shadow&&(e.castShadow=this.castShadow,V(e.shadow.mapSize,this.shadowMapSize),V(e.shadow.camera,this.shadowCamera)),["color","intensity","castShadow"].forEach(t=>{l(()=>this[t],r=>{t==="color"?e.color.set(r):e[t]=r})}),this.initObject3D(e),(e instanceof me||e instanceof fe)&&(u(this,"target",e.target,"position"),this.addToParent(e.target))}},__hmrId:"Light"}),$t=o({extends:Z,created(){this.initLight(new Ss(this.color,this.intensity))},__hmrId:"AmbientLight"}),zt=o({extends:Z,props:{target:{type:Object,default:()=>({x:0,y:0,z:0})}},created(){this.initLight(new fe(this.color,this.intensity))},__hmrId:"DirectionalLight"}),Tt=o({extends:Z,props:{groundColor:{type:String,default:"#444444"}},created(){const e=new Ps(this.color,this.groundColor,this.intensity);l(()=>this.groundColor,t=>{e.groundColor.set(t)}),this.initLight(e)},__hmrId:"HemisphereLight"}),It=o({extends:Z,props:{distance:{type:Number,default:0},decay:{type:Number,default:1}},created(){this.initLight(new ws(this.color,this.intensity,this.distance,this.decay))},__hmrId:"PointLight"}),At=o({extends:Z,props:{width:{type:Number,default:10},height:{type:Number,default:10},helper:Boolean},created(){Zs.init();const e=new xs(this.color,this.intensity,this.width,this.height);if(["width","height"].forEach(r=>{l(()=>this[r],s=>{e[r]=s})}),this.helper){const r=new Ys(e);e.add(r)}this.initLight(e)},__hmrId:"RectAreaLight"}),Bt=o({extends:Z,props:{angle:{type:Number,default:Math.PI/3},decay:{type:Number,default:1},distance:{type:Number,default:0},penumbra:{type:Number,default:0},target:Object},created(){const e=new me(this.color,this.intensity,this.distance,this.angle,this.penumbra,this.decay);["angle","decay","distance","penumbra"].forEach(r=>{l(()=>this[r],s=>{e[r]=s})}),this.initLight(e)},__hmrId:"SpotLight"});const he=Symbol("Material");var _=o({inject:{mesh:q},props:{color:{type:[String,Number],default:"#ffffff"},blending:{type:Number,default:Ms},alphaTest:{type:Number,default:0},depthTest:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!0},fog:{type:Boolean,default:!0},opacity:{type:Number,default:1},side:{type:Number,default:Cs},transparent:Boolean,vertexColors:Boolean},setup(){return{}},provide(){return{[he]:this}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}this.createMaterial&&(this.material=this.createMaterial(),this.mesh.setMaterial(this.material),this.addWatchers())},unmounted(){var e;(e=this.material)==null||e.dispose()},methods:{setProp(e,t,r=!1){this.material&&(this.material[e]=t,this.material.needsUpdate=r)},setTexture(e,t="map"){this.setProp(t,e,!0)},addWatchers(){["color","alphaTest","blending","depthTest","depthWrite","fog","opacity","side","transparent"].forEach(e=>{l(()=>this[e],t=>{e==="color"?this.material.color.set(t):this.material[e]=t})})}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Material"});const O={wireframe:{type:Boolean,default:!1},wireframeLinewidth:{type:Number,default:1}};var Ft=o({extends:_,props:{...O},methods:{createMaterial(){const e=new Ge(N(this.$props));return U(this,Object.keys(O),e),e}},__hmrId:"BasicMaterial"}),Dt=o({extends:_,props:{...O},methods:{createMaterial(){const e=new Ls(N(this.$props));return U(this,Object.keys(O),e),e}},__hmrId:"LambertMaterial"}),Ut=o({extends:_,props:{src:String,name:{type:String,default:"0404E8_0404B5_0404CB_3333FC"},flatShading:Boolean},methods:{createMaterial(){const e=this.src?this.src:ye(this.name),t=N(this.$props,["src","name"]);return t.matcap=new J().load(e),new Ns(t)}},__hmrId:"MatcapMaterial"}),Ht=o({extends:_,props:{emissive:{type:[Number,String],default:0},emissiveIntensity:{type:Number,default:1},reflectivity:{type:Number,default:1},shininess:{type:Number,default:30},specular:{type:[String,Number],default:1118481},flatShading:Boolean,...O},methods:{createMaterial(){const e=new Gs(N(this.$props));return["emissive","emissiveIntensity","reflectivity","shininess","specular"].forEach(r=>{l(()=>this[r],s=>{r==="emissive"||r==="specular"?e[r].set(s):e[r]=s})}),U(this,Object.keys(O),e),e}},__hmrId:"PhongMaterial"});const Xt={aoMapIntensity:{type:Number,default:1},bumpScale:{type:Number,default:1},displacementBias:{type:Number,default:0},displacementScale:{type:Number,default:1},emissive:{type:[String,Number],default:0},emissiveIntensity:{type:Number,default:1},envMapIntensity:{type:Number,default:1},lightMapIntensity:{type:Number,default:1},metalness:{type:Number,default:0},normalScale:{type:Object,default:()=>({x:1,y:1})},roughness:{type:Number,default:1},refractionRatio:{type:Number,default:.98},flatShading:Boolean};var ve=o({extends:_,props:{...Xt,...O},methods:{createMaterial(){const e=new _s(N(this.$props,["normalScale"]));return Object.keys(Xt).forEach(t=>{t!=="normalScale"&&l(()=>this[t],r=>{t==="emissive"?e[t].set(r):e[t]=r})}),u(this,"normalScale",e),U(this,Object.keys(O),e),e}},__hmrId:"StandardMaterial"}),Kt=o({extends:ve,props:{flatShading:Boolean},methods:{createMaterial(){return new js(N(this.$props))}},__hmrId:"PhysicalMaterial"});const pi=`
  varying vec2 vUv;
  void main(){
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
  }
`,yi=`
  varying vec2 vUv;
  void main() {
    gl_FragColor = vec4(vUv.x, vUv.y, 0., 1.0);
  }
`;var Wt=o({extends:_,props:{uniforms:{type:Object,default:()=>({})},vertexShader:{type:String,default:pi},fragmentShader:{type:String,default:yi}},methods:{createMaterial(){const e=new pe(N(this.$props,["color"]));return["vertexShader","fragmentShader"].forEach(t=>{l(()=>this[t],r=>{e[t]=r,e.needsUpdate=!0})}),e}},__hmrId:"ShaderMaterial"});function gi(e,t,r){return e.split(t).join(r)}const vi=K.meshphong_frag.slice(0,K.meshphong_frag.indexOf("void main() {")),bi=K.meshphong_frag.slice(K.meshphong_frag.indexOf("void main() {")),Si={uniforms:_e.merge([Es.phong.uniforms,{thicknessColor:{value:new se(16777215)},thicknessDistortion:{value:.1},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}}]),vertexShader:`
    #define USE_UV
    ${K.meshphong_vert}
  `,fragmentShader:`
    #define USE_UV
    #define SUBSURFACE

    ${vi}

    uniform float thicknessPower;
    uniform float thicknessScale;
    uniform float thicknessDistortion;
    uniform float thicknessAmbient;
    uniform float thicknessAttenuation;
    uniform vec3 thicknessColor;

    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {
      #ifdef USE_COLOR
        vec3 thickness = vColor * thicknessColor;
      #else
        vec3 thickness = thicknessColor;
      #endif
      vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));
      float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
      vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
      reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
    }
  `+bi.replace("#include <lights_fragment_begin>",gi(K.lights_fragment_begin,"RE_Direct( directLight, geometry, material, reflectedLight );",`
        RE_Direct( directLight, geometry, material, reflectedLight );
        #if defined( SUBSURFACE ) && defined( USE_UV )
          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);
        #endif
      `))},Vt={color:{type:[String,Number],default:"#ffffff"},thicknessColor:{type:[String,Number],default:"#ffffff"},thicknessDistortion:{type:Number,default:.4},thicknessAmbient:{type:Number,default:.01},thicknessAttenuation:{type:Number,default:.7},thicknessPower:{type:Number,default:2},thicknessScale:{type:Number,default:4}};var qt=o({extends:_,props:Vt,methods:{createMaterial(){const e=Si,t=_e.clone(e.uniforms);return Object.keys(Vt).forEach(s=>{const n=this[s];let a=s,i=n;["color","thicknessColor"].includes(s)&&(s==="color"&&(a="diffuse"),i=new se(n)),t[a].value=i}),new pe({...e,uniforms:t,lights:!0,transparent:this.transparent,vertexColors:this.vertexColors})}},__hmrId:"SubSurfaceMaterial"}),Zt=o({extends:_,props:{...O},methods:{createMaterial(){const e=new Os(N(this.$props));return U(this,Object.keys(O),e),e}},__hmrId:"ToonMaterial"}),be=o({inject:{material:he},props:{name:{type:String,default:"map"},uniform:String,src:String,onLoad:Function,onProgress:Function,onError:Function,encoding:{type:Number,default:ks},mapping:{type:Number,default:Rs},wrapS:{type:Number,default:je},wrapT:{type:Number,default:je},magFilter:{type:Number,default:$s},minFilter:{type:Number,default:Me},repeat:{type:Object,default:()=>({x:1,y:1})},rotation:{type:Number,default:0},center:{type:Object,default:()=>({x:0,y:0})}},setup(){return{}},created(){this.refreshTexture(),l(()=>this.src,this.refreshTexture)},unmounted(){var e,t;(e=this.material)==null||e.setTexture(null,this.name),(t=this.texture)==null||t.dispose()},methods:{createTexture(){if(!this.src)return;const e=new J().load(this.src,this.onLoaded,this.onProgress,this.onError);return["encoding","mapping","wrapS","wrapT","magFilter","minFilter","repeat","rotation","center"].forEach(r=>{u(this,r,e)}),e},refreshTexture(){this.texture=this.createTexture(),this.texture&&this.material&&(this.material.setTexture(this.texture,this.name),this.material.material instanceof pe&&this.uniform&&(this.material.uniforms[this.uniform]={value:this.texture}))},onLoaded(e){var t;(t=this.onLoad)==null||t.call(this,e)}},render(){return[]}}),Yt=o({extends:be,props:{path:{type:String,required:!0},urls:{type:Array,default:()=>["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]},mapping:{type:Number,default:zs}},created(){l(()=>this.path,this.refreshTexture),l(()=>this.urls,this.refreshTexture)},methods:{createTexture(){return new Ts().setPath(this.path).load(this.urls,this.onLoaded,this.onProgress,this.onError)}}}),Jt=o({extends:_,props:{size:{type:Number,default:10},sizeAttenuation:{type:Boolean,default:!0}},methods:{createMaterial(){return new Is(N(this.$props))}},__hmrId:"PointsMaterial"}),Qt=g("Box",Fe,De),er=g("Circle",He,Xe),tr=g("Cone",We,Ve),rr=g("Cylinder",Ze,Ye),sr=g("Dodecahedron",Qe,et),ir=g("Icosahedron",rt,st),nr=g("Lathe",nt,at),ar=g("Octahedron",ht,dt),or=g("Plane",ut,ct),hr=g("Polyhedron",ft,pt),dr=g("Ring",gt,vt),lr=g("Sphere",St,Pt),ur=g("Tetrahedron",xt,Mt);const Pi={text:{type:String,required:!0,default:"Text"},fontSrc:{type:String,required:!0},size:{type:Number,default:80},height:{type:Number,default:5},depth:{type:Number,default:1},curveSegments:{type:Number,default:12},bevelEnabled:{type:Boolean,default:!1},bevelThickness:{type:Number,default:10},bevelSize:{type:Number,default:8},bevelOffset:{type:Number,default:0},bevelSegments:{type:Number,default:5},align:{type:[Boolean,String],default:!1}};var cr=o({extends:H,props:Pi,setup(){return{}},created(){if(!this.fontSrc){console.error('Missing required prop: "font-src"');return}["text","size","height","curveSegments","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","align"].forEach(r=>{l(()=>this[r],()=>{this.font&&this.refreshGeometry()})});const t=new As;this.loading=!0,t.load(this.fontSrc,r=>{this.loading=!1,this.font=r,this.createGeometry(),this.initMesh()})},methods:{createGeometry(){this.geometry=new Bs(this.text,{font:this.font,size:this.size,height:this.height,depth:this.depth,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize,bevelOffset:this.bevelOffset,bevelSegments:this.bevelSegments}),this.align==="center"&&this.geometry.center()}}}),mr=g("Torus",Lt,Nt),fr=g("TorusKnot",_t,jt),pr=o({extends:H,props:ge,created(){this.createGeometry(),this.addGeometryWatchers(ge)},methods:{createGeometry(){this.geometry=Ot(this)},updatePoints(e){Rt(this.geometry,e)}},__hmrId:"Tube"}),yr=o({emits:["loaded"],extends:H,props:{src:{type:String,required:!0},width:Number,height:Number,widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},keepSize:Boolean},setup(){return{}},created(){!this.renderer||(this.geometry=new Le(1,1,this.widthSegments,this.heightSegments),this.material=new Ge({side:Fs,map:this.loadTexture()}),l(()=>this.src,this.refreshTexture),["width","height"].forEach(e=>{l(()=>this[e],this.resize)}),this.resize(),this.keepSize&&this.renderer.onResize(this.resize))},unmounted(){var e;(e=this.renderer)==null||e.offResize(this.resize)},methods:{loadTexture(){return new J().load(this.src,this.onLoaded)},refreshTexture(){var e;(e=this.texture)==null||e.dispose(),this.material&&(this.material.map=this.loadTexture(),this.material.needsUpdate=!0)},onLoaded(e){this.texture=e,this.resize(),this.$emit("loaded",e)},resize(){if(!this.renderer||!this.texture)return;const e=this.renderer.size,t=this.texture.image.width,r=this.texture.image.height,s=t/r;let n=1,a=1;this.width&&this.height?(n=this.width*e.wWidth/e.width,a=this.height*e.wHeight/e.height):this.width?(n=this.width*e.wWidth/e.width,a=n/s):this.height?(a=this.height*e.wHeight/e.height,n=a*s):s>1?n=a*s:a=n/s,this.mesh&&(this.mesh.scale.x=n,this.mesh.scale.y=a)}},__hmrId:"Image"}),gr=o({extends:H,props:{count:{type:Number,required:!0}},methods:{initMesh(){if(!!this.renderer){if(!this.geometry||!this.material)return console.error("Missing geometry and/or material"),!1;this.mesh=new ce(this.geometry,this.material,this.count),this.mesh.userData.component=this,u(this,"castShadow",this.mesh),u(this,"receiveShadow",this.mesh),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer.three.addIntersectObject(this.mesh),this.initObject3D(this.mesh)}}},__hmrId:"InstancedMesh"}),vr=o({extends:I,emits:["loaded"],props:{src:{type:String,required:!0}},setup(){return{}},created(){this.texture=new J().load(this.src,this.onLoaded),this.material=new Ds({map:this.texture}),this.sprite=new Us(this.material),this.initObject3D(this.sprite)},unmounted(){var e,t;(e=this.texture)==null||e.dispose(),(t=this.material)==null||t.dispose()},methods:{onLoaded(){this.updateUV(),this.$emit("loaded")},updateUV(){if(!this.texture||!this.sprite)return;const e=this.texture.image.width,t=this.texture.image.height,r=e/t;let s=.5,n=.5;r>1?s=.5*r:n=.5/r;const a=this.sprite.geometry.attributes.position.array;a[0]=-s,a[1]=-n,a[5]=s,a[6]=-n,a[10]=s,a[11]=n,a[15]=-s,a[16]=n,this.sprite.geometry.attributes.position.needsUpdate=!0}},__hmrId:"Sprite"}),br=o({extends:I,setup(){return{}},provide(){return{[q]:this}},mounted(){this.mesh=this.points=new Hs(this.geometry,this.material),this.initObject3D(this.mesh)},methods:{setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)}}}),Sr=o({extends:I,emits:["load","progress","error"],props:{src:{type:String,required:!0}},data(){return{progress:0}},methods:{onLoad(e){this.$emit("load",e),this.initObject3D(e)},onProgress(e){this.progress=e.loaded/e.total,this.$emit("progress",e)},onError(e){this.$emit("error",e)}}}),Pr=o({extends:Sr,created(){new Js().load(this.src,t=>{this.onLoad(t.scene)},this.onProgress,this.onError)}}),wr=o({extends:Sr,created(){new Qs().load(this.src,t=>{this.onLoad(t)},this.onProgress,this.onError)}});const de=Symbol("Composer");var xr=o({setup(){return{renderer:W(G)}},provide(){return{[de]:this}},created(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer,t=new ei(this.renderer.renderer);this.composer=t,this.renderer.composer=t,e.addListener("init",()=>{e.renderer.autoClear=!1,this.resize(),e.addListener("resize",this.resize)})},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{addPass(e){var t;(t=this.composer)==null||t.addPass(e)},removePass(e){var t;(t=this.composer)==null||t.removePass(e)},resize(){this.composer&&this.renderer&&this.composer.setSize(this.renderer.size.width,this.renderer.size.height)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"EffectComposer"}),k=o({inject:{renderer:G,composer:de},emits:["ready"],setup(){return{}},created(){this.composer||console.error("Missing parent EffectComposer"),this.renderer||console.error("Missing parent Renderer")},unmounted(){var e,t,r;this.pass&&((e=this.composer)==null||e.removePass(this.pass),(r=(t=this.pass).dispose)==null||r.call(t))},methods:{initEffectPass(e){var t;this.pass=e,(t=this.composer)==null||t.addPass(e),this.$emit("ready",e)}},render(){return[]},__hmrId:"EffectPass"}),Mr=o({extends:k,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new ti(this.renderer.scene,this.renderer.camera);this.initEffectPass(e)},__hmrId:"RenderPass"});const Cr={focus:{type:Number,default:1},aperture:{type:Number,default:.025},maxblur:{type:Number,default:.01}};var Lr=o({extends:k,props:Cr,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e={focus:this.focus,aperture:this.aperture,maxblur:this.maxblur,width:this.renderer.size.width,height:this.renderer.size.height},t=new ri(this.renderer.scene,this.renderer.camera,e);Object.keys(Cr).forEach(r=>{l(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"BokehPass"});const Nr={noiseIntensity:{type:Number,default:.5},scanlinesIntensity:{type:Number,default:.05},scanlinesCount:{type:Number,default:4096},grayscale:{type:Number,default:0}};var Gr=o({extends:k,props:Nr,created(){const e=new si(this.noiseIntensity,this.scanlinesIntensity,this.scanlinesCount,this.grayscale);Object.keys(Nr).forEach(t=>{l(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"FilmPass"}),_r=o({extends:k,created(){var e;const t=new ie(ii);(e=this.renderer)==null||e.addListener("resize",this.resize),this.initEffectPass(t)},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{resize({size:e}){if(this.pass){const{resolution:t}=this.pass.material.uniforms;t.value.x=1/e.width,t.value.y=1/e.height}}},__hmrId:"FXAAPass"});const jr={shape:{type:Number,default:1},radius:{type:Number,default:4},rotateR:{type:Number,default:Math.PI/12*1},rotateG:{type:Number,default:Math.PI/12*2},rotateB:{type:Number,default:Math.PI/12*3},scatter:{type:Number,default:0}};var Er=o({extends:k,props:jr,created(){if(!this.renderer)return;const e=new ni(this.renderer.size.width,this.renderer.size.height,{});Object.keys(jr).forEach(t=>{e.uniforms[t].value=this[t],l(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"HalftonePass"}),Or=o({extends:k,created(){if(!this.renderer)return;const e=new ai(this.renderer.size.width,this.renderer.size.height);this.initEffectPass(e)},__hmrId:"SMAAPass"}),kr=o({extends:k,props:{options:{type:Object,default:()=>({})}},created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new oi(this.renderer.scene,this.renderer.camera,this.renderer.size.width,this.renderer.size.height);Object.keys(this.options).forEach(t=>{e[t]=this.options[t]}),this.initEffectPass(e)},__hmrId:"SSAOPass"}),Rr={uniforms:{},vertexShader:`
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,fragmentShader:`
    varying vec2 vUv;
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
  `},$r={uniforms:{tDiffuse:{value:null},blurRadius:{value:0},gradientRadius:{value:0},start:{value:new T},end:{value:new T},delta:{value:new T},texSize:{value:new T}},vertexShader:Rr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform float blurRadius;
    uniform float gradientRadius;
    uniform vec2 start;
    uniform vec2 end;
    uniform vec2 delta;
    uniform vec2 texSize;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }

    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;

      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

      vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));
      float radius = smoothstep(0.0, 1.0, abs(dot(vUv * texSize - start, normal)) / gradientRadius) * blurRadius;
      for (float t = -30.0; t <= 30.0; t++) {
          float percent = (t + offset - 0.5) / 30.0;
          float weight = 1.0 - abs(percent);
          vec4 texel = texture2D(tDiffuse, vUv + delta / texSize * percent * radius);
          // vec4 texel2 = texture2D(tDiffuse, vUv + vec2(-delta.y, delta.x) / texSize * percent * radius);

          /* switch to pre-multiplied alpha to correctly blur transparent images */
          texel.rgb *= texel.a;
          // texel2.rgb *= texel2.a;

          color += texel * weight;
          total += 2.0 * weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `};const wi={blurRadius:{type:Number,default:10},gradientRadius:{type:Number,default:100},start:{type:Object,default:()=>({x:0,y:100})},end:{type:Object,default:()=>({x:10,y:100})}};var zr=o({extends:k,props:wi,setup(){return{uniforms1:{},uniforms2:{}}},created(){if(!this.composer)return;this.pass1=new ie($r),this.pass2=new ie($r);const e=this.uniforms1=this.pass1.uniforms,t=this.uniforms2=this.pass2.uniforms;t.blurRadius=e.blurRadius,t.gradientRadius=e.gradientRadius,t.start=e.start,t.end=e.end,t.texSize=e.texSize,u(this,"blurRadius",e.blurRadius,"value"),u(this,"gradientRadius",e.gradientRadius,"value"),this.updateFocusLine(),["start","end"].forEach(r=>{l(()=>this[r],this.updateFocusLine,{deep:!0})}),this.pass1.setSize=(r,s)=>{e.texSize.value.set(r,s)},this.initEffectPass(this.pass1),this.composer.addPass(this.pass2)},unmounted(){this.composer&&this.pass2&&this.composer.removePass(this.pass2)},methods:{updateFocusLine(){this.uniforms1.start.value.copy(this.start),this.uniforms1.end.value.copy(this.end);const e=new T().copy(this.end).sub(this.start).normalize();this.uniforms1.delta.value.copy(e),this.uniforms2.delta.value.set(-e.y,e.x)}},__hmrId:"TiltShiftPass"});const Tr={strength:{type:Number,default:1.5},radius:{type:Number,default:0},threshold:{type:Number,default:0}};var Ir=o({extends:k,props:Tr,created(){if(!this.renderer)return;const e=new T(this.renderer.size.width,this.renderer.size.height),t=new hi(e,this.strength,this.radius,this.threshold);Object.keys(Tr).forEach(r=>{l(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"UnrealBloomPass"}),xi={uniforms:{tDiffuse:{value:null},center:{value:new T(.5,.5)},strength:{value:0}},vertexShader:Rr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform vec2 center;
    uniform float strength;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }
    
    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;
      vec2 toCenter = center - vUv;
      
      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
      
      for (float t = 0.0; t <= 40.0; t++) {
        float percent = (t + offset) / 40.0;
        float weight = 4.0 * (percent - percent * percent);
        vec4 texel = texture2D(tDiffuse, vUv + toCenter * percent * strength);

        /* switch to pre-multiplied alpha to correctly blur transparent images */
        texel.rgb *= texel.a;

        color += texel * weight;
        total += weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `},Ar=o({extends:k,props:{center:{type:Object,default:()=>({x:.5,y:.5})},strength:{type:Number,default:.5}},created(){const e=new ie(xi);u(this,"center",e.uniforms.center,"value"),u(this,"strength",e.uniforms.strength,"value"),this.initEffectPass(e)},__hmrId:"ZoomBlurPass"}),Mi=Object.freeze({__proto__:null,Renderer:Re,RendererInjectionKey:G,OrthographicCamera:ze,PerspectiveCamera:ne,Camera:ne,Group:Ie,Scene:Te,SceneInjectionKey:ae,Object3D:I,Raycaster:Ae,CubeCamera:Be,BufferGeometry:oe,BoxGeometry:Ue,CircleGeometry:Ke,ConeGeometry:qe,CylinderGeometry:Je,DodecahedronGeometry:tt,IcosahedronGeometry:it,LatheGeometry:ot,OctahedronGeometry:lt,PlaneGeometry:mt,PolyhedronGeometry:yt,RingGeometry:bt,SphereGeometry:wt,TetrahedronGeometry:Ct,TorusGeometry:Gt,TorusKnotGeometry:Et,TubeGeometry:kt,AmbientLight:$t,DirectionalLight:zt,HemisphereLight:Tt,PointLight:It,RectAreaLight:At,SpotLight:Bt,Material:_,MaterialInjectionKey:he,BasicMaterial:Ft,LambertMaterial:Dt,MatcapMaterial:Ut,PhongMaterial:Ht,PhysicalMaterial:Kt,ShaderMaterial:Wt,StandardMaterial:ve,SubSurfaceMaterial:qt,ToonMaterial:Zt,Texture:be,CubeTexture:Yt,PointsMaterial:Jt,Mesh:H,MeshInjectionKey:q,Box:Qt,Circle:er,Cone:tr,Cylinder:rr,Dodecahedron:sr,Icosahedron:ir,Lathe:nr,Octahedron:ar,Plane:or,Polyhedron:hr,Ring:dr,Sphere:lr,Tetrahedron:ur,Text:cr,Torus:mr,TorusKnot:fr,Tube:pr,Image:yr,InstancedMesh:gr,Sprite:vr,Points:br,GLTFModel:Pr,FBXModel:wr,EffectComposer:xr,ComposerInjectionKey:de,RenderPass:Mr,BokehPass:Lr,FilmPass:Gr,FXAAPass:_r,HalftonePass:Er,SMAAPass:Or,SSAOPass:kr,TiltShiftPass:zr,UnrealBloomPass:Ir,ZoomBlurPass:Ar,setFromProp:V,bindProps:U,bindProp:u,propsValues:N,lerp:Ee,limit:Oe,getMatcapUrl:ye});const Br={install(e){["Camera","OrthographicCamera","PerspectiveCamera","Raycaster","Renderer","Scene","Group","CubeCamera","AmbientLight","DirectionalLight","HemisphereLight","PointLight","RectAreaLight","SpotLight","BasicMaterial","LambertMaterial","MatcapMaterial","PhongMaterial","PhysicalMaterial","PointsMaterial","ShaderMaterial","StandardMaterial","SubSurfaceMaterial","ToonMaterial","Texture","CubeTexture","BufferGeometry","Mesh","Box","BoxGeometry","Circle","CircleGeometry","Cone","ConeGeometry","Cylinder","CylinderGeometry","Dodecahedron","DodecahedronGeometry","Icosahedron","IcosahedronGeometry","Lathe","LatheGeometry","Octahedron","OctahedronGeometry","Plane","PlaneGeometry","Polyhedron","PolyhedronGeometry","Ring","RingGeometry","Sphere","SphereGeometry","Tetrahedron","TetrahedronGeometry","Text","Torus","TorusGeometry","TorusKnot","TorusKnotGeometry","Tube","TubeGeometry","Image","InstancedMesh","Points","Sprite","FBXModel","GLTFModel","BokehPass","EffectComposer","FilmPass","FXAAPass","HalftonePass","RenderPass","SAOPass","SMAAPass","SSAOPass","TiltShiftPass","UnrealBloomPass","ZoomBlurPass","GLTFViewer"].forEach(r=>{e.component(r,Mi[r])})}};function Ci(e){return Vs(e).use(Br)}function Li(){const e={loader:new J,count:0,textures:[],loadProgress:0,loadTextures:t,dispose:s};return e;function t(n,a){e.count=n.length,e.textures.splice(0),e.loadProgress=0,Promise.all(n.map(r)).then(a)}function r(n,a){return new Promise(i=>{e.loader.load(n.src,c=>{e.loadProgress+=1/e.count,e.textures[a]=c,i(c)})})}function s(){e.textures.forEach(n=>n.dispose())}}export{$t as AmbientLight,Ft as BasicMaterial,Lr as BokehPass,Qt as Box,Ue as BoxGeometry,oe as BufferGeometry,ne as Camera,er as Circle,Ke as CircleGeometry,de as ComposerInjectionKey,tr as Cone,qe as ConeGeometry,Be as CubeCamera,Yt as CubeTexture,rr as Cylinder,Je as CylinderGeometry,zt as DirectionalLight,sr as Dodecahedron,tt as DodecahedronGeometry,xr as EffectComposer,wr as FBXModel,_r as FXAAPass,Gr as FilmPass,Pr as GLTFModel,Ie as Group,Er as HalftonePass,Tt as HemisphereLight,ir as Icosahedron,it as IcosahedronGeometry,yr as Image,gr as InstancedMesh,Dt as LambertMaterial,nr as Lathe,ot as LatheGeometry,Ut as MatcapMaterial,_ as Material,he as MaterialInjectionKey,H as Mesh,q as MeshInjectionKey,I as Object3D,ar as Octahedron,lt as OctahedronGeometry,ze as OrthographicCamera,ne as PerspectiveCamera,Ht as PhongMaterial,Kt as PhysicalMaterial,or as Plane,mt as PlaneGeometry,It as PointLight,br as Points,Jt as PointsMaterial,hr as Polyhedron,yt as PolyhedronGeometry,Ae as Raycaster,At as RectAreaLight,Mr as RenderPass,Re as Renderer,G as RendererInjectionKey,dr as Ring,bt as RingGeometry,Or as SMAAPass,kr as SSAOPass,Te as Scene,ae as SceneInjectionKey,Wt as ShaderMaterial,lr as Sphere,wt as SphereGeometry,Bt as SpotLight,vr as Sprite,ve as StandardMaterial,qt as SubSurfaceMaterial,ur as Tetrahedron,Ct as TetrahedronGeometry,cr as Text,be as Texture,zr as TiltShiftPass,Zt as ToonMaterial,mr as Torus,Gt as TorusGeometry,fr as TorusKnot,Et as TorusKnotGeometry,Br as TroisJSVuePlugin,pr as Tube,kt as TubeGeometry,Ir as UnrealBloomPass,Ar as ZoomBlurPass,u as bindProp,U as bindProps,Ci as createApp,ye as getMatcapUrl,Ee as lerp,Oe as limit,N as propsValues,V as setFromProp,Li as useTextures};
//# sourceMappingURL=trois.module.min.js.map
