import{defineComponent as e,h as t,toRef as r,watch as s,createApp as i}from"vue";import{VRButton as a}from"three/examples/jsm/webxr/VRButton.js";import{Vector3 as n,Raycaster as o,Plane as h,Vector2 as d,InstancedMesh as m,WebGLRenderer as l,OrthographicCamera as u,PerspectiveCamera as c,Group as p,Scene as f,Color as g,BoxGeometry as y,CircleGeometry as b,ConeGeometry as v,CylinderGeometry as x,DodecahedronGeometry as S,IcosahedronGeometry as w,LatheGeometry as P,OctahedronGeometry as C,PolyhedronGeometry as N,RingGeometry as M,SphereGeometry as _,TetrahedronGeometry as L,TorusGeometry as j,TorusKnotGeometry as R,TubeGeometry as z,Curve as I,CatmullRomCurve3 as G,AmbientLight as k,DirectionalLight as B,HemisphereLight as O,PointLight as T,RectAreaLight as E,SpotLight as A,FrontSide as F,MeshBasicMaterial as U,MeshLambertMaterial as D,TextureLoader as $,MeshMatcapMaterial as W,MeshPhongMaterial as H,MeshStandardMaterial as X,MeshPhysicalMaterial as V,ShaderMaterial as K,ShaderChunk as Z,UniformsUtils as Y,ShaderLib as q,MeshToonMaterial as J,UVMapping as Q,ClampToEdgeWrapping as ee,LinearFilter as te,LinearMipmapLinearFilter as re,CubeTextureLoader as se,CubeRefractionMapping as ie,Mesh as ae,PlaneGeometry as ne,FontLoader as oe,TextGeometry as he,WebGLCubeRenderTarget as de,RGBFormat as me,CubeCamera as le,BackSide as ue,DoubleSide as ce,SpriteMaterial as pe,Sprite as fe}from"three";import{OrbitControls as ge}from"three/examples/jsm/controls/OrbitControls.js";import{RectAreaLightUniformsLib as ye}from"three/examples/jsm/lights/RectAreaLightUniformsLib.js";import{RectAreaLightHelper as be}from"three/examples/jsm/helpers/RectAreaLightHelper.js";import{GLTFLoader as ve}from"three/examples/jsm/loaders/GLTFLoader.js";import{FBXLoader as xe}from"three/examples/jsm/loaders/FBXLoader.js";import{EffectComposer as Se}from"three/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass as we}from"three/examples/jsm/postprocessing/RenderPass.js";import{BokehPass as Pe}from"three/examples/jsm/postprocessing/BokehPass.js";import{FilmPass as Ce}from"three/examples/jsm/postprocessing/FilmPass.js";import{ShaderPass as Ne}from"three/examples/jsm/postprocessing/ShaderPass.js";import{FXAAShader as Me}from"three/examples/jsm/shaders/FXAAShader.js";import{HalftonePass as _e}from"three/examples/jsm/postprocessing/HalftonePass.js";import{SMAAPass as Le}from"three/examples/jsm/postprocessing/SMAAPass.js";import{SSAOPass as je}from"three/examples/jsm/postprocessing/SSAOPass.js";import{UnrealBloomPass as Re}from"three/examples/jsm/postprocessing/UnrealBloomPass.js";function ze(e){const{camera:t,domElement:r,intersectObjects:s,touch:i=!0,resetOnEnd:a=!1,resetPosition:l=new d(0,0),resetPositionV3:u=new n(0,0,0),onEnter:c=(()=>{}),onMove:p=(()=>{}),onLeave:f=(()=>{}),onIntersectEnter:g=(()=>{}),onIntersectOver:y=(()=>{}),onIntersectMove:b=(()=>{}),onIntersectLeave:v=(()=>{}),onIntersectClick:x=(()=>{})}=e,S=l.clone(),w=new d(0,0),P=function(e){const{camera:t,resetPosition:r=new n(0,0,0)}=e,s=new o,i=r.clone(),a=new h(new n(0,0,1),0);return{position:i,updatePosition:e=>{s.setFromCamera(e,t),t.getWorldDirection(a.normal),s.ray.intersectPlane(a,i)},intersect:(e,r)=>(s.setFromCamera(e,t),s.intersectObjects(r))}}({camera:t}),C=P.position,N={position:S,positionN:w,positionV3:C,intersectObjects:s,listeners:!1,addListeners:function(){r.addEventListener("mouseenter",L),r.addEventListener("mousemove",j),r.addEventListener("mouseleave",z),r.addEventListener("click",R),i&&(r.addEventListener("touchstart",L),r.addEventListener("touchmove",j),r.addEventListener("touchend",z));N.listeners=!0},removeListeners:function(){r.removeEventListener("mouseenter",L),r.removeEventListener("mousemove",j),r.removeEventListener("mouseleave",z),r.removeEventListener("click",R),r.removeEventListener("touchstart",L),r.removeEventListener("touchmove",j),r.removeEventListener("touchend",z),N.listeners=!1},intersect:_};return N;function M(e){let t,s;e.touches&&e.touches.length>0?(t=e.touches[0].clientX,s=e.touches[0].clientY):(t=e.clientX,s=e.clientY);const i=r.getBoundingClientRect();S.x=t-i.left,S.y=s-i.top,w.x=S.x/i.width*2-1,w.y=-S.y/i.height*2+1,P.updatePosition(w)}function _(){if(s.length){const e=P.intersect(w,s),t=[...s],r=[];e.forEach((e=>{const{object:s}=e,{component:i}=s;if(s instanceof m){if(-1!==r.indexOf(s))return;r.push(s)}if(!s.over){s.over=!0;const t={type:"pointerover",over:!0,component:i,intersect:e},r={...t,type:"pointerenter"};y(t),g(r),i.onPointerOver?.(t),i.onPointerEnter?.(r)}const a={type:"pointermove",component:i,intersect:e};b(a),i.onPointerMove?.(a),t.splice(t.indexOf(s),1)})),t.forEach((e=>{const{component:t}=e;if(e.over){e.over=!1;const r={type:"pointerover",over:!1,component:t},s={...r,type:"pointerleave"};y(r),v(s),t.onPointerOver?.(r),t.onPointerLeave?.(s)}}))}}function L(e){M(e),c({type:"pointerenter",position:S,positionN:w,positionV3:C})}function j(e){M(e),p({type:"pointermove",position:S,positionN:w,positionV3:C}),_()}function R(e){if(M(e),s.length){const e=P.intersect(w,s),t=[];e.forEach((e=>{const{object:r}=e,{component:s}=r;if(r instanceof m){if(-1!==t.indexOf(r))return;t.push(r)}const i={type:"click",component:s,intersect:e};x(i),s.onClick?.(i)}))}}function z(){a&&(S.copy(l),C.copy(u)),f({type:"pointerleave"})}}function Ie(){const e={canvas:null,antialias:!0,alpha:!1,autoClear:!0,orbit_ctrl:!1,pointer:!1,resize:!1,width:300,height:150},t={width:1,height:1,wWidth:1,wHeight:1,ratio:1},r=[];let s=[],i=[];const a=[],n={conf:e,renderer:null,camera:null,cameraCtrl:null,scene:null,pointer:null,size:t,init:function(t){t&&Object.entries(t).forEach((([t,r])=>{e[t]=r}));if(!n.scene)return void console.error("Missing Scene");if(!n.camera)return void console.error("Missing Camera");n.renderer=new l({canvas:e.canvas,antialias:e.antialias,alpha:e.alpha}),n.renderer.autoClear=e.autoClear,e.resize?(d(),window.addEventListener("resize",d)):m(e.width,e.height);o(),e.orbit_ctrl&&(n.orbitCtrl=new ge(n.camera,n.renderer.domElement),e.orbit_ctrl instanceof Object&&Object.entries(e.orbit_ctrl).forEach((([e,t])=>{n.orbitCtrl[e]=t})));return r.forEach((e=>e())),!0},dispose:function(){i=[],window.removeEventListener("resize",d),n.pointer&&n.pointer.removeListeners();n.orbitCtrl&&n.orbitCtrl.dispose();n.renderer.dispose()},render:function(){n.orbitCtrl&&n.orbitCtrl.update();i.forEach((e=>e())),n.renderer.render(n.scene,n.camera)},renderC:function(){n.orbitCtrl&&n.orbitCtrl.update();i.forEach((e=>e())),n.composer.render()},setSize:m,onAfterInit:function(e){r.push(e)},onAfterResize:function(e){s.push(e)},offAfterResize:function(e){s=s.filter((t=>t!==e))},onBeforeRender:h,offBeforeRender:function(e){i=i.filter((t=>t!==e))},addIntersectObject:function(e){-1===a.indexOf(e)&&a.push(e);n.pointer&&!n.pointer.listeners&&n.pointer.addListeners()},removeIntersectObject:function(t){const r=a.indexOf(t);-1!==r&&a.splice(r,1);n.pointer&&!e.pointer&&0===a.length&&n.pointer.removeListeners()}};function o(){let t={camera:n.camera,domElement:n.renderer.domElement,intersectObjects:a};e.pointer&&e.pointer instanceof Object&&(t={...t,...e.pointer}),n.pointer=ze(t),(e.pointer||a.length)&&(n.pointer.addListeners(),"frame"===e.pointer.intersectMode&&h((()=>{n.pointer.intersect()})))}function h(e){i.push(e)}function d(){if("window"===e.resize)m(window.innerWidth,window.innerHeight);else{const e=n.renderer.domElement.parentNode;m(e.clientWidth,e.clientHeight)}s.forEach((e=>e()))}function m(e,r){if(t.width=e,t.height=r,t.ratio=e/r,n.renderer.setSize(e,r,!1),n.camera.aspect=t.ratio,n.camera.updateProjectionMatrix(),n.composer&&n.composer.setSize(e,r),"OrthographicCamera"===n.camera.type)t.wWidth=n.camera.right-n.camera.left,t.wHeight=n.camera.top-n.camera.bottom;else{const e=function(){const e=n.camera.fov*Math.PI/180,t=2*Math.tan(e/2)*Math.abs(n.camera.position.z);return[t*n.camera.aspect,t]}();t.wWidth=e[0],t.wHeight=e[1]}}return n}var Ge=e({name:"Renderer",props:{antialias:Boolean,alpha:Boolean,autoClear:{type:Boolean,default:!0},orbitCtrl:{type:[Boolean,Object],default:!1},pointer:{type:[Boolean,Object],default:!1},resize:{type:[Boolean,String],default:!1},shadow:Boolean,width:String,height:String,xr:Boolean},setup:()=>({three:Ie(),raf:!0,onMountedCallbacks:[]}),provide(){return{three:this.three,rendererComponent:this}},mounted(){const e={canvas:this.$el,antialias:this.antialias,alpha:this.alpha,autoClear:this.autoClear,orbit_ctrl:this.orbitCtrl,pointer:this.pointer,resize:this.resize,width:this.width,height:this.height};this.three.init(e)&&(this.renderer=this.three.renderer,this.renderer.shadowMap.enabled=this.shadow,this.xr?(this.vrButton=a.createButton(this.renderer),this.renderer.domElement.parentNode.appendChild(this.vrButton),this.renderer.xr.enabled=!0,this.three.composer?this.renderer.setAnimationLoop(this.animateXRC):this.renderer.setAnimationLoop(this.animateXR)):this.three.composer?this.animateC():this.animate()),this.onMountedCallbacks.forEach((e=>e()))},beforeUnmount(){this.raf=!1,this.three.dispose()},methods:{onMounted(e){this.onMountedCallbacks.push(e)},onBeforeRender(e){this.three.onBeforeRender(e)},onAfterResize(e){this.three.onAfterResize(e)},animate(){this.raf&&requestAnimationFrame(this.animate),this.three.render()},animateC(){this.raf&&requestAnimationFrame(this.animateC),this.three.renderC()},animateXR(){this.three.render()},animateXRC(){this.three.renderC()}},render(){return t("canvas",{},this.$slots.default())},__hmrId:"Renderer"});function ke(e,t){t instanceof Object&&Object.entries(t).forEach((([t,r])=>{e[t]=r}))}function Be(e,t,r){t.forEach((t=>{Oe(e,t,r)}))}function Oe(e,t,i,a){a||(a=t);const n=r(e,t);n.value instanceof Object?(ke(i[a],n.value),s(n,(e=>{ke(i[a],e)}),{deep:!0})):(n.value&&(i[a]=e[t]),s(n,(e=>{i[a]=e})))}function Te(e,t){const r={};return Object.entries(e).forEach((([e,s])=>{(!t||t&&!t.includes(e))&&(r[e]=s)})),r}function Ee(e,t,r){return e+(t-e)*(r=(r=r<0?0:r)>1?1:r)}function Ae(e,t,r){e.x=Ee(e.x,t.x,r),e.y=Ee(e.y,t.y,r)}function Fe(e,t,r){e.x=Ee(e.x,t.x,r),e.y=Ee(e.y,t.y,r),e.z=Ee(e.z,t.z,r)}function Ue(e,t,r){return e<t?t:e>r?r:e}function De(e,t=1024){return`https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d/${t}/${`${e}${function(e){switch(e){case 64:return"-64px";case 128:return"-128px";case 256:return"-256px";case 512:return"-512px";default:return""}}(t)}.png`}`}var $e=e({inject:["three"],render(){return this.$slots.default?this.$slots.default():[]}}),We=e({extends:$e,name:"OrthographicCamera",inject:["three"],props:{left:{type:Number,default:-1},right:{type:Number,default:1},top:{type:Number,default:1},bottom:{type:Number,default:-1},near:{type:Number,default:.1},far:{type:Number,default:2e3},zoom:{type:Number,default:1},position:{type:Object,default:{x:0,y:0,z:0}}},created(){this.camera=new u(this.left,this.right,this.top,this.bottom,this.near,this.far),Oe(this,"position",this.camera),["left","right","top","bottom","near","far","zoom"].forEach((e=>{s((()=>this[e]),(()=>{this.camera[e]=this[e],this.camera.updateProjectionMatrix()}))})),this.three.camera=this.camera},__hmrId:"OrthographicCamera"}),He=e({extends:$e,name:"PerspectiveCamera",inject:["three"],props:{aspect:{type:Number,default:1},far:{type:Number,default:2e3},fov:{type:Number,default:50},near:{type:Number,default:.1},position:{type:Object,default:{x:0,y:0,z:0}},lookAt:{type:Object,default:null}},created(){this.camera=new c(this.fov,this.aspect,this.near,this.far),Oe(this,"position",this.camera),this.lookAt&&this.camera.lookAt(this.lookAt.x,this.lookAt.y,this.lookAt.z),s((()=>this.lookAt),(e=>{this.camera.lookAt(e.x,e.y,e.z)}),{deep:!0}),["aspect","far","fov","near"].forEach((e=>{s((()=>this[e]),(()=>{this.camera[e]=this[e],this.camera.updateProjectionMatrix()}))})),this.three.camera=this.camera},__hmrId:"PerspectiveCamera"}),Xe=e({name:"Object3D",inject:["three","scene","rendererComponent"],emits:["created","ready"],props:{position:{type:Object,default:{x:0,y:0,z:0}},rotation:{type:Object,default:{x:0,y:0,z:0}},scale:{type:Object,default:{x:1,y:1,z:1}},lookAt:{type:Object,default:null},autoRemove:{type:Boolean,default:!0}},unmounted(){this.autoRemove&&this.removeFromParent()},methods:{initObject3D(e){this.o3d=e,this.$emit("created",this.o3d),Oe(this,"position",this.o3d),Oe(this,"rotation",this.o3d),Oe(this,"scale",this.o3d),this.lookAt&&this.o3d.lookAt(this.lookAt.x,this.lookAt.y,this.lookAt.z),s((()=>this.lookAt),(e=>{this.o3d.lookAt(e.x,e.y,e.z)}),{deep:!0}),this._parent=this.getParent(),this.addToParent()?this.$emit("ready",this):console.error("Missing parent (Scene, Group...)")},getParent(){let e=this.$parent;for(;e;){if(e.add)return e;e=e.$parent}return!1},addToParent(e){const t=e||this.o3d;return!!this._parent&&(this._parent.add(t),!0)},removeFromParent(e){const t=e||this.o3d;return!!this._parent&&(this._parent.remove(t),!0)},add(e){this.o3d.add(e)},remove(e){this.o3d.remove(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Object3D"}),Ve=e({name:"Group",extends:Xe,created(){this.group=new p,this.initObject3D(this.group)},__hmrId:"Group"}),Ke=e({name:"Scene",inject:["three"],props:{id:String,background:[String,Number]},setup(e){const t=new f;return e.background&&(t.background=new g(e.background)),s((()=>e.background),(e=>{t.background.set(e)})),{scene:t}},provide(){return{scene:this.scene}},mounted(){this.three.scene||(this.three.scene=this.scene)},methods:{add(e){this.scene.add(e)},remove(e){this.scene.remove(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Scene"}),Ze=e({name:"Raycaster",inject:["three","rendererComponent"],props:{onPointerEnter:{type:Function,default:()=>{}},onPointerOver:{type:Function,default:()=>{}},onPointerMove:{type:Function,default:()=>{}},onPointerLeave:{type:Function,default:()=>{}},onClick:{type:Function,default:()=>{}},intersectMode:{type:String,default:"move"}},mounted(){this.rendererComponent.onMounted((()=>{this.pointer=ze({camera:this.three.camera,domElement:this.three.renderer.domElement,intersectObjects:this.getIntersectObjects(),onIntersectEnter:this.onPointerEnter,onIntersectOver:this.onPointerOver,onIntersectMove:this.onPointerMove,onIntersectLeave:this.onPointerLeave,onIntersectClick:this.onClick}),this.pointer.addListeners(),"frame"===this.intersectMode&&this.three.onBeforeRender(this.pointer.intersect)}))},unmounted(){this.pointer&&(this.pointer.removeListeners(),this.three.offBeforeRender(this.pointer.intersect))},methods:{getIntersectObjects(){return this.three.scene.children.filter((e=>"Mesh"===e.type))}},render:()=>[],__hmrId:"Raycaster"});const Ye=e({inject:["mesh"],props:{rotateX:Number,rotateY:Number,rotateZ:Number},created(){this.mesh||console.error("Missing parent Mesh"),this.watchProps=[],Object.entries(this.$props).forEach((e=>this.watchProps.push(e[0]))),this.createGeometry(),this.rotateGeometry(),this.mesh.setGeometry(this.geometry),this.addWatchers()},unmounted(){this.geometry.dispose()},methods:{addWatchers(){this.watchProps.forEach((e=>{s((()=>this[e]),(()=>{this.refreshGeometry()}))}))},rotateGeometry(){this.rotateX&&this.geometry.rotateX(this.rotateX),this.rotateY&&this.geometry.rotateY(this.rotateY),this.rotateZ&&this.geometry.rotateZ(this.rotateZ)},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.rotateGeometry(),this.mesh.setGeometry(this.geometry),e.dispose()}},render:()=>[]});function qe(t,r,s){return e({name:t,extends:Ye,props:r,methods:{createGeometry(){this.geometry=s(this)}}})}const Je={size:Number,width:{type:Number,default:1},height:{type:Number,default:1},depth:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},depthSegments:{type:Number,default:1}};function Qe(e){return e.size?new y(e.size,e.size,e.size,e.widthSegments,e.heightSegments,e.depthSegments):new y(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}var et=qe("BoxGeometry",Je,Qe);const tt={radius:{type:Number,default:1},segments:{type:Number,default:8},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:2*Math.PI}};function rt(e){return new b(e.radius,e.segments,e.thetaStart,e.thetaLength)}var st=qe("CircleGeometry",tt,rt);const it={radius:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:2*Math.PI}};function at(e){return new v(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var nt=qe("ConeGeometry",it,at);const ot={radiusTop:{type:Number,default:1},radiusBottom:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:2*Math.PI}};function ht(e){return new x(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var dt=qe("CylinderGeometry",ot,ht);const mt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function lt(e){return new S(e.radius,e.detail)}var ut=qe("DodecahedronGeometry",mt,lt);const ct={radius:{type:Number,default:1},detail:{type:Number,default:0}};function pt(e){return new w(e.radius,e.detail)}var ft=qe("IcosahedronGeometry",ct,pt);const gt={points:Array,segments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:2*Math.PI}};function yt(e){return new P(e.points,e.segments,e.phiStart,e.phiLength)}var bt=qe("LatheGeometry",gt,yt);const vt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function xt(e){return new C(e.radius,e.detail)}var St=qe("OctahedronGeometry",vt,xt);const wt={vertices:Array,indices:Array,radius:{type:Number,default:1},detail:{type:Number,default:0}};function Pt(e){return new N(e.vertices,e.indices,e.radius,e.detail)}var Ct=qe("PolyhedronGeometry",wt,Pt);const Nt={innerRadius:{type:Number,default:.5},outerRadius:{type:Number,default:1},thetaSegments:{type:Number,default:8},phiSegments:{type:Number,default:1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:2*Math.PI}};function Mt(e){return new M(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}var _t=qe("RingGeometry",Nt,Mt);const Lt={radius:{type:Number,default:1},widthSegments:{type:Number,default:12},heightSegments:{type:Number,default:12}};function jt(e){return new _(e.radius,e.widthSegments,e.heightSegments)}var Rt=qe("SphereGeometry",Lt,jt);const zt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function It(e){return new L(e.radius,e.detail)}var Gt=qe("TetrahedronGeometry",zt,It);const kt={radius:{type:Number,default:1},tube:{type:Number,default:.4},radialSegments:{type:Number,default:8},tubularSegments:{type:Number,default:6},arc:{type:Number,default:2*Math.PI}};function Bt(e){return new j(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}var Ot=qe("TorusGeometry",kt,Bt);const Tt={radius:{type:Number,default:1},tube:{type:Number,default:.4},tubularSegments:{type:Number,default:64},radialSegments:{type:Number,default:8},p:{type:Number,default:2},q:{type:Number,default:3}};function Et(e){return new R(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}var At=qe("TorusKnotGeometry",Tt,Et);const Ft={points:Array,path:I,tubularSegments:{type:Number,default:64},radius:{type:Number,default:1},radialSegments:{type:Number,default:8},closed:{type:Boolean,default:!1}};function Ut(e){let t;return e.points?t=new G(e.points):e.path?t=e.path:console.error("Missing path curve or points."),new z(t,e.tubularSegments,e.radius,e.radiusSegments,e.closed)}var Dt=e({extends:Ye,props:Ft,methods:{createGeometry(){this.geometry=Ut(this)},updatePoints(e){$t(this.geometry,e)}}});function $t(e,t){const r=new G(t),{radialSegments:s,radius:i,tubularSegments:a,closed:o}=e.parameters,h=r.computeFrenetFrames(a,o);e.tangents=h.tangents,e.normals=h.normals,e.binormals=h.binormals,e.parameters.path=r;const d=e.attributes.position.array,m=e.attributes.normal.array,l=new n;let u;for(let e=0;e<a;e++)c(e);function c(e){u=r.getPointAt(e/a,u);const t=h.normals[e],n=h.binormals[e];for(let r=0;r<=s;r++){const a=r/s*Math.PI*2,o=Math.sin(a),h=-Math.cos(a);l.x=h*t.x+o*n.x,l.y=h*t.y+o*n.y,l.z=h*t.z+o*n.z,l.normalize();const c=3*(e*(s+1)+r);m[c]=l.x,m[c+1]=l.y,m[c+2]=l.z,d[c]=u.x+i*l.x,d[c+1]=u.y+i*l.y,d[c+2]=u.z+i*l.z}}c(a),e.attributes.position.needsUpdate=!0,e.attributes.normal.needsUpdate=!0}var Wt=e({extends:Xe,name:"Light",props:{color:{type:String,default:"#ffffff"},intensity:{type:Number,default:1},castShadow:{type:Boolean,default:!1},shadowMapSize:{type:Object,default:{x:512,y:512}},shadowCamera:{type:Object,default:{}}},unmounted(){this.light.target&&this.removeFromParent(this.light.target)},methods:{initLight(){this.light.target&&Oe(this,"target",this.light.target,"position"),this.light.shadow&&(this.light.castShadow=this.castShadow,ke(this.light.shadow.mapSize,this.shadowMapSize),ke(this.light.shadow.camera,this.shadowCamera)),["color","intensity","castShadow"].forEach((e=>{s((()=>this[e]),(()=>{"color"===e?this.light.color.set(this.color):this.light[e]=this[e]}))})),this.initObject3D(this.light),this.light.target&&this.addToParent(this.light.target)}},__hmrId:"Light"}),Ht=e({extends:Wt,created(){this.light=new k(this.color,this.intensity),this.initLight()},__hmrId:"AmbientLight"}),Xt=e({extends:Wt,props:{target:Object},created(){this.light=new B(this.color,this.intensity),this.initLight()},__hmrId:"DirectionalLight"}),Vt=e({extends:Wt,props:{groundColor:{type:String,default:"#444444"}},created(){this.light=new O(this.color,this.groundColor,this.intensity),s((()=>this.groundColor),(e=>{this.light.groundColor.set(e)})),this.initLight()},__hmrId:"HemisphereLight"}),Kt=e({extends:Wt,props:{distance:{type:Number,default:0},decay:{type:Number,default:1}},created(){this.light=new T(this.color,this.intensity,this.distance,this.decay),this.initLight()},__hmrId:"PointLight"}),Zt=e({extends:Wt,props:{width:{type:Number,default:10},height:{type:Number,default:10},helper:Boolean},created(){ye.init(),this.light=new E(this.color,this.intensity,this.width,this.height),["width","height"].forEach((e=>{s((()=>this[e]),(()=>{this.light[e]=this[e]}))})),this.helper&&(this.lightHelper=new be(this.light),this.light.add(this.lightHelper)),this.initLight()},unmounted(){this.lightHelper&&this.removeFromParent(this.lightHelper)},__hmrId:"RectAreaLight"}),Yt=e({extends:Wt,props:{angle:{type:Number,default:Math.PI/3},decay:{type:Number,default:1},distance:{type:Number,default:0},penumbra:{type:Number,default:0},target:Object},created(){this.light=new A(this.color,this.intensity,this.distance,this.angle,this.penumbra,this.decay),["angle","decay","distance","penumbra"].forEach((e=>{s((()=>this[e]),(()=>{this.light[e]=this[e]}))})),this.initLight()},__hmrId:"SpotLight"}),qt=e({inject:["three","mesh"],props:{color:{type:[String,Number],default:"#ffffff"},depthTest:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!0},fog:{type:Boolean,default:!0},opacity:{type:Number,default:1},side:{type:Number,default:F},transparent:Boolean,vertexColors:Boolean},provide(){return{material:this}},created(){this.createMaterial(),this.mesh.setMaterial(this.material),this._addWatchers(),this.addWatchers&&this.addWatchers()},unmounted(){this.material.dispose()},methods:{setProp(e,t,r=!1){this.material[e]=t,this.material.needsUpdate=r},setTexture(e,t="map"){this.setProp(t,e,!0)},_addWatchers(){["color","depthTest","depthWrite","fog","opacity","side","transparent"].forEach((e=>{s((()=>this[e]),(()=>{"color"===e?this.material.color.set(this.color):this.material[e]=this[e]}))}))}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Material"});const Jt={wireframe:{type:Boolean,default:!1},wireframeLinewidth:{type:Number,default:1}};var Qt=e({extends:qt,props:{...Jt},methods:{createMaterial(){this.material=new U(Te(this.$props))},addWatchers(){Be(this,Object.keys(Jt),this.material)}},__hmrId:"BasicMaterial"}),er=e({extends:qt,props:{...Jt},methods:{createMaterial(){this.material=new D(Te(this.$props))},addWatchers(){Be(this,Object.keys(Jt),this.material)}},__hmrId:"LambertMaterial"}),tr=e({extends:qt,props:{src:String,name:String,flatShading:Boolean},methods:{createMaterial(){const e=this.name?De(this.name):this.src,t=Te(this.$props,["src","name"]);t.matcap=(new $).load(e),this.material=new W(t)},addWatchers(){}},__hmrId:"MatcapMaterial"}),rr=e({extends:qt,props:{emissive:{type:[Number,String],default:0},emissiveIntensity:{type:Number,default:1},reflectivity:{type:Number,default:1},shininess:{type:Number,default:30},specular:{type:[String,Number],default:1118481},flatShading:Boolean,...Jt},methods:{createMaterial(){this.material=new H(Te(this.$props))},addWatchers(){["emissive","emissiveIntensity","reflectivity","shininess","specular"].forEach((e=>{s((()=>this[e]),(t=>{"emissive"===e||"specular"===e?this.material[e].set(t):this.material[e]=t}))})),Be(this,Object.keys(Jt),this.material)}},__hmrId:"PhongMaterial"});const sr={aoMapIntensity:{type:Number,default:1},bumpScale:{type:Number,default:1},displacementBias:{type:Number,default:0},displacementScale:{type:Number,default:1},emissive:{type:[Number,String],default:0},emissiveIntensity:{type:Number,default:1},envMapIntensity:{type:Number,default:1},lightMapIntensity:{type:Number,default:1},metalness:{type:Number,default:0},normalScale:{type:Object,default:{x:1,y:1}},roughness:{type:Number,default:1},refractionRatio:{type:Number,default:.98},flatShading:Boolean};var ir=e({extends:qt,props:{...sr,...Jt},methods:{createMaterial(){this.material=new X(Te(this.$props,["normalScale"]))},addWatchers(){Object.keys(sr).forEach((e=>{"normalScale"!==e&&s((()=>this[e]),(t=>{"emissive"===e?this.material[e].set(t):this.material[e]=t}))})),Oe(this,"normalScale",this.material),Be(this,Object.keys(Jt),this.material)}},__hmrId:"StandardMaterial"}),ar=e({extends:ir,props:{flatShading:Boolean},methods:{createMaterial(){this.material=new V(Te(this.$props))},addWatchers(){}},__hmrId:"PhysicalMaterial"});var nr=e({inject:["three","mesh"],props:{uniforms:{type:Object,default:()=>({})},vertexShader:{type:String,default:"\nvarying vec2 vUv;\nvoid main(){\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n}"},fragmentShader:{type:String,default:"\nvarying vec2 vUv;\nvoid main() {\n  gl_FragColor = vec4(vUv.x, vUv.y, 0., 1.0);\n}"}},provide(){return{material:this}},created(){this.createMaterial(),["vertexShader","fragmentShader"].forEach((e=>{s((()=>this[e]),(()=>{this.material.dispose(),this.createMaterial()}))}))},unmounted(){this.material.dispose()},methods:{createMaterial(){this.material=new K(Te(this.$props)),this.mesh.setMaterial(this.material)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"ShaderMaterial"});const or=Z.meshphong_frag.slice(0,Z.meshphong_frag.indexOf("void main() {")),hr=Z.meshphong_frag.slice(Z.meshphong_frag.indexOf("void main() {")),dr={uniforms:Y.merge([q.phong.uniforms,{thicknessColor:{value:new g(16777215)},thicknessDistortion:{value:.1},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}}]),vertexShader:`\n    #define USE_UV\n    ${Z.meshphong_vert}\n  `,fragmentShader:`\n    #define USE_UV\n    #define SUBSURFACE\n\n    ${or}\n\n    uniform float thicknessPower;\n    uniform float thicknessScale;\n    uniform float thicknessDistortion;\n    uniform float thicknessAmbient;\n    uniform float thicknessAttenuation;\n    uniform vec3 thicknessColor;\n\n    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n      #ifdef USE_COLOR\n        vec3 thickness = vColor * thicknessColor;\n      #else\n        vec3 thickness = thicknessColor;\n      #endif\n      vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n      float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n      vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n      reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n    }\n  `+hr.replace("#include <lights_fragment_begin>",(mr=Z.lights_fragment_begin,lr="RE_Direct( directLight, geometry, material, reflectedLight );",ur="\n        RE_Direct( directLight, geometry, material, reflectedLight );\n        #if defined( SUBSURFACE ) && defined( USE_UV )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      ",mr.split(lr).join(ur)))};var mr,lr,ur,cr=e({inject:["three","mesh"],props:{color:{type:String,default:"#ffffff"},thicknessColor:{type:String,default:"#ffffff"},thicknessDistortion:{type:Number,default:.4},thicknessAmbient:{type:Number,default:.01},thicknessAttenuation:{type:Number,default:.7},thicknessPower:{type:Number,default:2},thicknessScale:{type:Number,default:4},transparent:{type:Boolean,default:!1},opacity:{type:Number,default:1},vertexColors:{type:Boolean,default:!1}},created(){this.createMaterial(),this.mesh.setMaterial(this.material)},unmounted(){this.material.dispose()},methods:{createMaterial(){const e=dr,t=Y.clone(e.uniforms);Object.entries(this.$props).forEach((([e,r])=>{let s=e,i=r;["color","thicknessColor"].includes(e)&&("color"===e&&(s="diffuse"),i=new g(r)),["transparent","vertexColors"].includes(e)||(t[s].value=i)})),this.material=new K({...e,uniforms:t,lights:!0,transparent:this.transparent,vertexColors:this.vertexColors})}},render:()=>[],__hmrId:"SubSurfaceMaterial"}),pr=e({extends:qt,props:{...Jt},methods:{createMaterial(){this.material=new J(Te(this.$props))},addWatchers(){Be(this,Object.keys(Jt),this.material)}},__hmrId:"ToonMaterial"}),fr=e({inject:["material"],emits:["loaded"],props:{name:{type:String,default:"map"},uniform:{type:String,default:null},src:String,onLoad:Function,onProgress:Function,onError:Function,mapping:{type:Number,default:Q},wrapS:{type:Number,default:ee},wrapT:{type:Number,default:ee},magFilter:{type:Number,default:te},minFilter:{type:Number,default:re},repeat:{type:Object,default:{x:1,y:1}},rotation:{type:Number,default:0},center:{type:Object,default:{x:0,y:0}}},created(){this.refreshTexture(),s((()=>this.src),this.refreshTexture)},unmounted(){this.material&&this.material.setTexture&&this.material.setTexture(null,this.name),this.texture.dispose()},methods:{createTexture(){this.texture=(new $).load(this.src,this.onLoaded,this.onProgress,this.onError);["mapping","wrapS","wrapT","magFilter","minFilter","repeat","rotation","rotation","center"].forEach((e=>{Oe(this,e,this.texture)}))},refreshTexture(){if(this.createTexture(),this.material&&this.material.setTexture)this.material.setTexture(this.texture,this.name);else if(this.material&&"ShaderMaterial"===this.material.material.type){if(!this.uniform)return void console.warn('"uniform" prop required to use texture in a shader.');this.material.uniforms[this.uniform]={value:this.texture}}},onLoaded(){this.onLoad&&this.onLoad(),this.$emit("loaded")}},render:()=>[]}),gr=e({inject:["material"],emits:["loaded"],props:{path:String,urls:{type:Array,default:["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]},onLoad:Function,onProgress:Function,onError:Function,name:{type:String,default:"envMap"},refraction:Boolean,refractionRatio:{type:Number,default:.98}},created(){this.refreshTexture(),s((()=>this.path),this.refreshTexture),s((()=>this.urls),this.refreshTexture)},unmounted(){this.material.setTexture(null,this.name),this.texture.dispose()},methods:{createTexture(){this.texture=(new se).setPath(this.path).load(this.urls,this.onLoaded,this.onProgress,this.onError)},refreshTexture(){this.createTexture(),this.material.setTexture(this.texture,this.name),this.refraction&&(this.texture.mapping=ie,this.material.setProp("refractionRatio",this.refractionRatio))},onLoaded(){this.onLoad&&this.onLoad(),this.$emit("loaded")}},render:()=>[]});const yr={onPointerEnter:Function,onPointerOver:Function,onPointerMove:Function,onPointerLeave:Function,onPointerDown:Function,onPointerUp:Function,onClick:Function},br=e({name:"Mesh",extends:Xe,props:{castShadow:Boolean,receiveShadow:Boolean,...yr},provide(){return{mesh:this}},mounted(){this.mesh||this.loading||this.initMesh()},methods:{initMesh(){this.mesh=new ae(this.geometry,this.material),this.mesh.component=this,Oe(this,"castShadow",this.mesh),Oe(this,"receiveShadow",this.mesh),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.three.addIntersectObject(this.mesh),this.initObject3D(this.mesh)},addGeometryWatchers(e){Object.keys(e).forEach((e=>{s((()=>this[e]),(()=>{this.refreshGeometry()}))}))},setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.mesh.geometry=this.geometry,e.dispose()}},unmounted(){this.mesh&&this.three.removeIntersectObject(this.mesh),this.geometry&&this.geometry.dispose()},__hmrId:"Mesh"});function vr(t,r,s){return e({name:t,extends:br,props:r,created(){this.createGeometry(),this.addGeometryWatchers(r)},methods:{createGeometry(){this.geometry=s(this)}},__hmrId:t})}var xr=vr("Box",Je,Qe),Sr=vr("Circle",tt,rt),wr=vr("Cone",it,at),Pr=vr("Cylinder",ot,ht),Cr=vr("Dodecahedron",mt,lt),Nr=vr("Icosahedron",ct,pt),Mr=vr("Lathe",gt,yt),_r=vr("Octahedron",vt,xt);const Lr={width:{type:Number,default:1},height:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1}};function jr(e){return new ne(e.width,e.height,e.widthSegments,e.heightSegments)}qe("PlaneGeometry",Lr,jr);var Rr=vr("Plane",Lr,jr),zr=vr("Polyhedron",wt,Pt),Ir=vr("Ring",Nt,Mt),Gr=vr("Sphere",Lt,jt),kr=vr("Tetrahedron",zt,It);const Br={text:String,fontSrc:String,size:{type:Number,default:80},height:{type:Number,default:5},depth:{type:Number,default:1},curveSegments:{type:Number,default:12},bevelEnabled:{type:Boolean,default:!1},bevelThickness:{type:Number,default:10},bevelSize:{type:Number,default:8},bevelOffset:{type:Number,default:0},bevelSegments:{type:Number,default:5},align:{type:[Boolean,String],default:!1}};var Or=e({extends:br,props:Br,data:()=>({loading:!0}),created(){["text","size","height","curveSegments","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","align"].forEach((e=>{s((()=>this[e]),(()=>{this.font&&this.refreshGeometry()}))}));(new oe).load(this.fontSrc,(e=>{this.loading=!1,this.font=e,this.createGeometry(),this.initMesh()}))},methods:{createGeometry(){this.geometry=new he(this.text,{font:this.font,size:this.size,height:this.height,depth:this.depth,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize,bevelOffset:this.bevelOffset,bevelSegments:this.bevelSegments}),"center"===this.align&&this.geometry.center()}}}),Tr=vr("Torus",kt,Bt),Er=vr("TorusKnot",Tt,Et),Ar=e({extends:br,props:Ft,created(){this.createGeometry(),this.addGeometryWatchers(Ft)},methods:{createGeometry(){this.geometry=Ut(this)},updatePoints(e){$t(this.geometry,e)}},__hmrId:"Tube"}),Fr=e({extends:br,props:{cubeRTSize:{type:Number,default:256},cubeCameraNear:{type:Number,default:.1},cubeCameraFar:{type:Number,default:2e3},autoUpdate:Boolean},mounted(){this.initGem(),this.autoUpdate?this.three.onBeforeRender(this.updateCubeRT):this.rendererComponent.onMounted(this.updateCubeRT)},unmounted(){this.three.offBeforeRender(this.updateCubeRT),this.cubeCamera&&this.removeFromParent(this.cubeCamera),this.meshBack&&this.removeFromParent(this.meshBack),this.materialBack&&this.materialBack.dispose()},methods:{initGem(){const e=new de(this.cubeRTSize,{format:me,generateMipmaps:!0,minFilter:re});this.cubeCamera=new le(this.cubeCameraNear,this.cubeCameraFar,e),Oe(this,"position",this.cubeCamera),this.addToParent(this.cubeCamera),this.material.side=F,this.material.envMap=e.texture,this.material.envMapIntensity=10,this.material.metalness=0,this.material.roughness=0,this.material.opacity=.75,this.material.transparent=!0,this.material.premultipliedAlpha=!0,this.material.needsUpdate=!0,this.materialBack=this.material.clone(),this.materialBack.side=ue,this.materialBack.envMapIntensity=5,this.materialBack.metalness=1,this.materialBack.roughness=0,this.materialBack.opacity=.5,this.meshBack=new ae(this.geometry,this.materialBack),Oe(this,"position",this.meshBack),Oe(this,"rotation",this.meshBack),Oe(this,"scale",this.meshBack),this.addToParent(this.meshBack)},updateCubeRT(){this.mesh.visible=!1,this.meshBack.visible=!1,this.cubeCamera.update(this.three.renderer,this.scene),this.mesh.visible=!0,this.meshBack.visible=!0}},__hmrId:"Gem"}),Ur=e({emits:["loaded"],extends:br,props:{src:String,width:Number,height:Number,keepSize:Boolean},created(){this.createGeometry(),this.createMaterial(),this.initMesh(),s((()=>this.src),this.refreshTexture),["width","height"].forEach((e=>{s((()=>this[e]),this.resize)})),this.keepSize&&this.three.onAfterResize(this.resize)},methods:{createGeometry(){this.geometry=new ne(1,1,1,1)},createMaterial(){this.material=new U({side:ce,map:this.loadTexture()})},loadTexture(){return(new $).load(this.src,this.onLoaded)},refreshTexture(){this.texture&&this.texture.dispose(),this.material.map=this.loadTexture(),this.material.needsUpdate=!0},onLoaded(e){this.texture=e,this.resize(),this.$emit("loaded")},resize(){if(!this.texture)return;const e=this.three.size,t=this.texture.image.width/this.texture.image.height;let r,s;this.width&&this.height?(r=this.width*e.wWidth/e.width,s=this.height*e.wHeight/e.height):this.width?(r=this.width*e.wWidth/e.width,s=r/t):this.height&&(s=this.height*e.wHeight/e.height,r=s*t),this.mesh.scale.x=r,this.mesh.scale.y=s}},__hmrId:"Image"}),Dr=e({extends:Xe,props:{castShadow:Boolean,receiveShadow:Boolean,count:Number,...yr},provide(){return{mesh:this}},beforeMount(){this.$slots.default||console.error("Missing Geometry")},mounted(){this.initMesh()},methods:{initMesh(){this.mesh=new m(this.geometry,this.material,this.count),this.mesh.component=this,Oe(this,"castShadow",this.mesh),Oe(this,"receiveShadow",this.mesh),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.three.addIntersectObject(this.mesh),this.initObject3D(this.mesh)},setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.material.instancingColor=!0,this.mesh&&(this.mesh.material=e)}},unmounted(){this.mesh&&this.three.removeIntersectObject(this.mesh)},__hmrId:"InstancedMesh"}),$r=e({extends:br,props:{cubeRTSize:{type:Number,default:256},cubeCameraNear:{type:Number,default:.1},cubeCameraFar:{type:Number,default:2e3},autoUpdate:Boolean},mounted(){this.initMirrorMesh(),this.autoUpdate?this.three.onBeforeRender(this.updateCubeRT):this.rendererComponent.onMounted(this.updateCubeRT)},unmounted(){this.three.offBeforeRender(this.updateCubeRT),this.cubeCamera&&this.removeFromParent(this.cubeCamera)},methods:{initMirrorMesh(){const e=new de(this.cubeRTSize,{format:me,generateMipmaps:!0,minFilter:re});this.cubeCamera=new le(this.cubeCameraNear,this.cubeCameraFar,e),this.addToParent(this.cubeCamera),this.material.envMap=e.texture,this.material.needsUpdate=!0},updateCubeRT(){this.mesh.visible=!1,this.cubeCamera.update(this.three.renderer,this.scene),this.mesh.visible=!0}},__hmrId:"MirrorMesh"}),Wr=e({extends:br,props:{cubeRTSize:{type:Number,default:256},cubeCameraNear:{type:Number,default:.1},cubeCameraFar:{type:Number,default:2e3},refractionRatio:{type:Number,default:.98},autoUpdate:Boolean},mounted(){this.initMirrorMesh(),this.autoUpdate?this.three.onBeforeRender(this.updateCubeRT):this.rendererComponent.onMounted(this.updateCubeRT)},unmounted(){this.three.offBeforeRender(this.updateCubeRT),this.cubeCamera&&this.removeFromParent(this.cubeCamera)},methods:{initMirrorMesh(){const e=new de(this.cubeRTSize,{mapping:ie,format:me,generateMipmaps:!0,minFilter:re});this.cubeCamera=new le(this.cubeCameraNear,this.cubeCameraFar,e),Oe(this,"position",this.cubeCamera),this.addToParent(this.cubeCamera),this.material.envMap=e.texture,this.material.refractionRatio=this.refractionRatio,this.material.needsUpdate=!0},updateCubeRT(){this.mesh.visible=!1,this.cubeCamera.update(this.three.renderer,this.scene),this.mesh.visible=!0}},__hmrId:"RefractionMesh"}),Hr=e({extends:Xe,emits:["loaded"],props:{src:String},data:()=>({loading:!0}),created(){this.texture=(new $).load(this.src,this.onLoaded),this.material=new pe({map:this.texture}),this.sprite=new fe(this.material),this.geometry=this.sprite.geometry,this.initObject3D(this.sprite)},unmounted(){this.texture.dispose(),this.material.dispose()},methods:{onLoaded(){this.loading=!1,this.updateUV(),this.$emit("loaded")},updateUV(){this.iWidth=this.texture.image.width,this.iHeight=this.texture.image.height,this.iRatio=this.iWidth/this.iHeight;let e=.5,t=.5;this.iRatio>1?t=.5/this.iRatio:e=.5/this.iRatio;const r=this.geometry.attributes.position.array;r[0]=-e,r[1]=-t,r[5]=e,r[6]=-t,r[10]=e,r[11]=t,r[15]=-e,r[16]=t,this.geometry.attributes.position.needsUpdate=!0}},__hmrId:"Sprite"}),Xr=e({extends:Xe,emits:["load","progress","error"],data:()=>({progress:0}),methods:{onLoad(e){this.$emit("load",e),this.initObject3D(e)},onProgress(e){this.progress=e.loaded/e.total,this.$emit("progress",e)},onError(e){this.$emit("error",e)}}}),Vr=e({extends:Xr,props:{src:String},created(){(new ve).load(this.src,(e=>{this.onLoad(e.scene)}),this.onProgress,this.onError)}}),Kr=e({extends:Xr,props:{src:String},created(){(new xe).load(this.src,(e=>{this.onLoad(e)}),this.onProgress,this.onError)}}),Zr=e({setup:()=>({passes:[]}),inject:["three"],provide(){return{passes:this.passes}},mounted(){this.three.onAfterInit((()=>{this.composer=new Se(this.three.renderer),this.three.renderer.autoClear=!1,this.passes.forEach((e=>{this.composer.addPass(e)})),this.three.composer=this.composer,this.resize(),this.three.onAfterResize(this.resize)}))},unmounted(){this.three.offAfterResize(this.resize)},methods:{resize(){this.composer.setSize(this.three.size.width,this.three.size.height)}},render(){return this.$slots.default()},__hmrId:"EffectComposer"}),Yr=e({inject:["three","passes"],emits:["ready"],beforeMount(){this.passes||console.error("Missing parent EffectComposer")},unmounted(){this.pass.dispose&&this.pass.dispose()},methods:{completePass(e){this.passes.push(e),this.pass=e,this.$emit("ready",e)}},render:()=>[],__hmrId:"EffectPass"}),qr=e({extends:Yr,mounted(){this.three.scene||console.error("Missing Scene"),this.three.camera||console.error("Missing Camera");const e=new we(this.three.scene,this.three.camera);this.completePass(e)},__hmrId:"RenderPass"}),Jr=e({extends:Yr,props:{focus:{type:Number,default:1},aperture:{type:Number,default:.025},maxblur:{type:Number,default:.01}},watch:{focus(){this.pass.uniforms.focus.value=this.focus},aperture(){this.pass.uniforms.aperture.value=this.aperture},maxblur(){this.pass.uniforms.maxblur.value=this.maxblur}},mounted(){this.three.scene||console.error("Missing Scene"),this.three.camera||console.error("Missing Camera");const e={focus:this.focus,aperture:this.aperture,maxblur:this.maxblur,width:this.three.size.width,height:this.three.size.height},t=new Pe(this.three.scene,this.three.camera,e);this.completePass(t)},__hmrId:"BokehPass"}),Qr=e({extends:Yr,props:{noiseIntensity:{type:Number,default:.5},scanlinesIntensity:{type:Number,default:.05},scanlinesCount:{type:Number,default:4096},grayscale:{type:Number,default:0}},watch:{noiseIntensity(){this.pass.uniforms.nIntensity.value=this.noiseIntensity},scanlinesIntensity(){this.pass.uniforms.sIntensity.value=this.scanlinesIntensity},scanlinesCount(){this.pass.uniforms.sCount.value=this.scanlinesCount},grayscale(){this.pass.uniforms.grayscale.value=this.grayscale}},mounted(){const e=new Ce(this.noiseIntensity,this.scanlinesIntensity,this.scanlinesCount,this.grayscale);this.completePass(e)},__hmrId:"FilmPass"}),es=e({extends:Yr,mounted(){const e=new Ne(Me);this.completePass(e),this.three.onAfterResize(this.resize)},unmounted(){this.three.offAfterResize(this.resize)},methods:{resize(){const{resolution:e}=this.pass.material.uniforms;e.value.x=1/this.three.size.width,e.value.y=1/this.three.size.height}},__hmrId:"FXAAPass"}),ts=e({extends:Yr,props:{shape:{type:Number,default:1},radius:{type:Number,default:4},rotateR:{type:Number,default:Math.PI/12*1},rotateG:{type:Number,default:Math.PI/12*2},rotateB:{type:Number,default:Math.PI/12*3},scatter:{type:Number,default:0}},mounted(){const e=new _e(this.three.size.width,this.three.size.height,{});["shape","radius","rotateR","rotateG","rotateB","scatter"].forEach((t=>{e.uniforms[t].value=this[t],s((()=>this[t]),(()=>{e.uniforms[t].value=this[t]}))})),this.completePass(e)},__hmrId:"HalftonePass"}),rs=e({extends:Yr,mounted(){const e=new Le(this.three.size.width,this.three.size.height);this.completePass(e)},__hmrId:"SMAAPass"}),ss=e({extends:Yr,props:{scene:null,camera:null,options:{type:Object,default:()=>({})}},mounted(){const e=new je(this.scene||this.three.scene,this.camera||this.three.camera,this.three.size.width,this.three.size.height);for(const t of Object.keys(this.options))e[t]=this.options[t];this.completePass(e)},__hmrId:"SSAOPass"}),is={uniforms:{},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n    void main() {\n      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n  "},as={uniforms:{tDiffuse:{value:null},blurRadius:{value:0},gradientRadius:{value:0},start:{value:new d},end:{value:new d},delta:{value:new d},texSize:{value:new d}},vertexShader:is.vertexShader,fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform float blurRadius;\n    uniform float gradientRadius;\n    uniform vec2 start;\n    uniform vec2 end;\n    uniform vec2 delta;\n    uniform vec2 texSize;\n    varying vec2 vUv;\n\n    float random(vec3 scale, float seed) {\n      /* use the fragment position for a different seed per-pixel */\n      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n\n    void main() {\n      vec4 color = vec4(0.0);\n      float total = 0.0;\n\n      /* randomize the lookup values to hide the fixed number of samples */\n      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n      vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n      float radius = smoothstep(0.0, 1.0, abs(dot(vUv * texSize - start, normal)) / gradientRadius) * blurRadius;\n      for (float t = -30.0; t <= 30.0; t++) {\n          float percent = (t + offset - 0.5) / 30.0;\n          float weight = 1.0 - abs(percent);\n          vec4 texel = texture2D(tDiffuse, vUv + delta / texSize * percent * radius);\n          // vec4 texel2 = texture2D(tDiffuse, vUv + vec2(-delta.y, delta.x) / texSize * percent * radius);\n\n          /* switch to pre-multiplied alpha to correctly blur transparent images */\n          texel.rgb *= texel.a;\n          // texel2.rgb *= texel2.a;\n\n          color += texel * weight;\n          total += 2.0 * weight;\n      }\n\n      gl_FragColor = color / total;\n\n      /* switch back from pre-multiplied alpha */\n      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n    }\n  "},ns=e({extends:Yr,props:{blurRadius:{type:Number,default:10},gradientRadius:{type:Number,default:100},start:{type:Object,default:{x:0,y:100}},end:{type:Object,default:{x:10,y:100}}},mounted(){this.pass=new Ne(as),this.passes.push(this.pass),this.pass1=new Ne(as),this.passes.push(this.pass1);const e=this.uniforms=this.pass.uniforms,t=this.uniforms1=this.pass1.uniforms;t.blurRadius=e.blurRadius,t.gradientRadius=e.gradientRadius,t.start=e.start,t.end=e.end,t.texSize=e.texSize,Oe(this,"blurRadius",e.blurRadius,"value"),Oe(this,"gradientRadius",e.gradientRadius,"value"),this.updateFocusLine(),["start","end"].forEach((e=>{s((()=>this[e]),this.updateFocusLine,{deep:!0})})),this.pass.setSize=(t,r)=>{e.texSize.value.set(t,r)},this.$emit("ready",[this.pass,this.pass1])},methods:{updateFocusLine(){this.uniforms.start.value.copy(this.start),this.uniforms.end.value.copy(this.end);const e=(new d).copy(this.end).sub(this.start).normalize();this.uniforms.delta.value.copy(e),this.uniforms1.delta.value.set(-e.y,e.x)}},__hmrId:"TiltShiftPass"}),os=e({extends:Yr,props:{strength:{type:Number,default:1.5},radius:{type:Number,default:0},threshold:{type:Number,default:0}},watch:{strength(){this.pass.strength=this.strength},radius(){this.pass.radius=this.radius},threshold(){this.pass.threshold=this.threshold}},mounted(){const e=new d(this.three.size.width,this.three.size.height),t=new Re(e,this.strength,this.radius,this.threshold);this.completePass(t)},__hmrId:"UnrealBloomPass"}),hs={uniforms:{tDiffuse:{value:null},center:{value:new d(.5,.5)},strength:{value:0}},vertexShader:is.vertexShader,fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform vec2 center;\n    uniform float strength;\n    varying vec2 vUv;\n\n    float random(vec3 scale, float seed) {\n      /* use the fragment position for a different seed per-pixel */\n      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n    \n    void main() {\n      vec4 color = vec4(0.0);\n      float total = 0.0;\n      vec2 toCenter = center - vUv;\n      \n      /* randomize the lookup values to hide the fixed number of samples */\n      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n      \n      for (float t = 0.0; t <= 40.0; t++) {\n        float percent = (t + offset) / 40.0;\n        float weight = 4.0 * (percent - percent * percent);\n        vec4 texel = texture2D(tDiffuse, vUv + toCenter * percent * strength);\n\n        /* switch to pre-multiplied alpha to correctly blur transparent images */\n        texel.rgb *= texel.a;\n\n        color += texel * weight;\n        total += weight;\n      }\n\n      gl_FragColor = color / total;\n\n      /* switch back from pre-multiplied alpha */\n      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n    }\n  "},ds=e({extends:Yr,props:{center:{type:Object,default:{x:.5,y:.5}},strength:{type:Number,default:.5}},mounted(){const e=new Ne(hs),t=this.uniforms=e.uniforms;Oe(this,"center",t.center,"value"),Oe(this,"strength",t.strength,"value"),this.completePass(e)},__hmrId:"ZoomBlurPass"}),ms=Object.freeze({__proto__:null,Renderer:Ge,OrthographicCamera:We,PerspectiveCamera:He,Camera:He,Group:Ve,Scene:Ke,Object3D:Xe,Raycaster:Ze,BoxGeometry:et,CircleGeometry:st,ConeGeometry:nt,CylinderGeometry:dt,DodecahedronGeometry:ut,IcosahedronGeometry:ft,LatheGeometry:bt,OctahedronGeometry:St,PolyhedronGeometry:Ct,RingGeometry:_t,SphereGeometry:Rt,TetrahedronGeometry:Gt,TorusGeometry:Ot,TorusKnotGeometry:At,TubeGeometry:Dt,AmbientLight:Ht,DirectionalLight:Xt,HemisphereLight:Vt,PointLight:Kt,RectAreaLight:Zt,SpotLight:Yt,BasicMaterial:Qt,LambertMaterial:er,MatcapMaterial:tr,PhongMaterial:rr,PhysicalMaterial:ar,ShaderMaterial:nr,StandardMaterial:ir,SubSurfaceMaterial:cr,ToonMaterial:pr,Texture:fr,CubeTexture:gr,Mesh:br,Box:xr,Circle:Sr,Cone:wr,Cylinder:Pr,Dodecahedron:Cr,Icosahedron:Nr,Lathe:Mr,Octahedron:_r,Plane:Rr,Polyhedron:zr,Ring:Ir,Sphere:Gr,Tetrahedron:kr,Text:Or,Torus:Tr,TorusKnot:Er,Tube:Ar,Gem:Fr,Image:Ur,InstancedMesh:Dr,MirrorMesh:$r,RefractionMesh:Wr,Sprite:Hr,GLTFModel:Vr,FBXModel:Kr,EffectComposer:Zr,RenderPass:qr,BokehPass:Jr,FilmPass:Qr,FXAAPass:es,HalftonePass:ts,SMAAPass:rs,SSAOPass:ss,TiltShiftPass:ns,UnrealBloomPass:os,ZoomBlurPass:ds,setFromProp:ke,bindProps:Be,bindProp:Oe,propsValues:Te,lerp:Ee,lerpv2:Ae,lerpv3:Fe,limit:Ue,getMatcapUrl:De});const ls={install:e=>{["Camera","OrthographicCamera","PerspectiveCamera","Raycaster","Renderer","Scene","Group","AmbientLight","DirectionalLight","HemisphereLight","PointLight","RectAreaLight","SpotLight","BasicMaterial","LambertMaterial","MatcapMaterial","PhongMaterial","PhysicalMaterial","ShaderMaterial","StandardMaterial","SubSurfaceMaterial","ToonMaterial","Texture","CubeTexture","Mesh","Box","BoxGeometry","Circle","CircleGeometry","Cone","ConeGeometry","Cylinder","CylinderGeometry","Dodecahedron","DodecahedronGeometry","Icosahedron","IcosahedronGeometry","Lathe","LatheGeometry","Octahedron","OctahedronGeometry","Plane","Polyhedron","PolyhedronGeometry","Ring","RingGeometry","Sphere","SphereGeometry","Tetrahedron","TetrahedronGeometry","Text","Torus","TorusGeometry","TorusKnot","TorusKnotGeometry","Tube","TubeGeometry","Gem","Image","InstancedMesh","MirrorMesh","RefractionMesh","Sprite","FBXModel","GLTFModel","BokehPass","EffectComposer","FilmPass","FXAAPass","HalftonePass","RenderPass","SAOPass","SMAAPass","SSAOPass","TiltShiftPass","UnrealBloomPass","ZoomBlurPass","GLTFViewer"].forEach((t=>{e.component(t,ms[t])}))}};function us(e){return i(e).use(ls)}export{Ht as AmbientLight,Qt as BasicMaterial,Jr as BokehPass,xr as Box,et as BoxGeometry,He as Camera,Sr as Circle,st as CircleGeometry,wr as Cone,nt as ConeGeometry,gr as CubeTexture,Pr as Cylinder,dt as CylinderGeometry,Xt as DirectionalLight,Cr as Dodecahedron,ut as DodecahedronGeometry,Zr as EffectComposer,Kr as FBXModel,es as FXAAPass,Qr as FilmPass,Vr as GLTFModel,Fr as Gem,Ve as Group,ts as HalftonePass,Vt as HemisphereLight,Nr as Icosahedron,ft as IcosahedronGeometry,Ur as Image,Dr as InstancedMesh,er as LambertMaterial,Mr as Lathe,bt as LatheGeometry,tr as MatcapMaterial,br as Mesh,$r as MirrorMesh,Xe as Object3D,_r as Octahedron,St as OctahedronGeometry,We as OrthographicCamera,He as PerspectiveCamera,rr as PhongMaterial,ar as PhysicalMaterial,Rr as Plane,Kt as PointLight,zr as Polyhedron,Ct as PolyhedronGeometry,Ze as Raycaster,Zt as RectAreaLight,Wr as RefractionMesh,qr as RenderPass,Ge as Renderer,Ir as Ring,_t as RingGeometry,rs as SMAAPass,ss as SSAOPass,Ke as Scene,nr as ShaderMaterial,Gr as Sphere,Rt as SphereGeometry,Yt as SpotLight,Hr as Sprite,ir as StandardMaterial,cr as SubSurfaceMaterial,kr as Tetrahedron,Gt as TetrahedronGeometry,Or as Text,fr as Texture,ns as TiltShiftPass,pr as ToonMaterial,Tr as Torus,Ot as TorusGeometry,Er as TorusKnot,At as TorusKnotGeometry,ls as TroisJSVuePlugin,Ar as Tube,Dt as TubeGeometry,os as UnrealBloomPass,ds as ZoomBlurPass,Oe as bindProp,Be as bindProps,us as createApp,De as getMatcapUrl,Ee as lerp,Ae as lerpv2,Fe as lerpv3,Ue as limit,Te as propsValues,ke as setFromProp};
//# sourceMappingURL=trois.module.min.js.map
