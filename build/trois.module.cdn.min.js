import{defineComponent as e,h as t,toRef as r,watch as s,createApp as i}from"https://unpkg.com/vue@3.0.11/dist/vue.esm-browser.prod.js";import{Vector3 as a,Raycaster as n,Plane as o,Vector2 as h,InstancedMesh as d,WebGLRenderer as l,OrthographicCamera as m,PerspectiveCamera as u,Group as c,Scene as p,Color as f,BoxGeometry as g,CircleGeometry as y,ConeGeometry as b,CylinderGeometry as v,DodecahedronGeometry as S,IcosahedronGeometry as x,LatheGeometry as w,OctahedronGeometry as P,PlaneGeometry as N,PolyhedronGeometry as M,RingGeometry as C,SphereGeometry as L,TetrahedronGeometry as _,TorusGeometry as j,TorusKnotGeometry as k,TubeGeometry as z,Curve as I,CatmullRomCurve3 as O,AmbientLight as G,DirectionalLight as E,HemisphereLight as R,PointLight as A,RectAreaLight as T,SpotLight as B,FrontSide as F,MeshBasicMaterial as D,MeshLambertMaterial as U,TextureLoader as $,MeshMatcapMaterial as W,MeshPhongMaterial as H,MeshStandardMaterial as X,MeshPhysicalMaterial as V,ShaderMaterial as K,ShaderChunk as Z,UniformsUtils as Y,ShaderLib as q,MeshToonMaterial as J,UVMapping as Q,ClampToEdgeWrapping as ee,LinearFilter as te,LinearMipmapLinearFilter as re,CubeTextureLoader as se,CubeRefractionMapping as ie,Mesh as ae,FontLoader as ne,TextGeometry as oe,DoubleSide as he,SpriteMaterial as de,Sprite as le}from"https://unpkg.com/three@0.127.0/build/three.module.js";import{OrbitControls as me}from"https://unpkg.com/three@0.127.0/examples/jsm/controls/OrbitControls.js";import{RectAreaLightUniformsLib as ue}from"https://unpkg.com/three@0.127.0/examples/jsm/lights/RectAreaLightUniformsLib.js";import{RectAreaLightHelper as ce}from"https://unpkg.com/three@0.127.0/examples/jsm/helpers/RectAreaLightHelper.js";import{GLTFLoader as pe}from"https://unpkg.com/three@0.127.0/examples/jsm/loaders/GLTFLoader.js";import{FBXLoader as fe}from"https://unpkg.com/three@0.127.0/examples/jsm/loaders/FBXLoader.js";import{EffectComposer as ge}from"https://unpkg.com/three@0.127.0/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass as ye}from"https://unpkg.com/three@0.127.0/examples/jsm/postprocessing/RenderPass.js";import{BokehPass as be}from"https://unpkg.com/three@0.127.0/examples/jsm/postprocessing/BokehPass.js";import{FilmPass as ve}from"https://unpkg.com/three@0.127.0/examples/jsm/postprocessing/FilmPass.js";import{ShaderPass as Se}from"https://unpkg.com/three@0.127.0/examples/jsm/postprocessing/ShaderPass.js";import{FXAAShader as xe}from"https://unpkg.com/three@0.127.0/examples/jsm/shaders/FXAAShader.js";import{HalftonePass as we}from"https://unpkg.com/three@0.127.0/examples/jsm/postprocessing/HalftonePass.js";import{SMAAPass as Pe}from"https://unpkg.com/three@0.127.0/examples/jsm/postprocessing/SMAAPass.js";import{SSAOPass as Ne}from"https://unpkg.com/three@0.127.0/examples/jsm/postprocessing/SSAOPass.js";import{UnrealBloomPass as Me}from"https://unpkg.com/three@0.127.0/examples/jsm/postprocessing/UnrealBloomPass.js";function Ce(e){const{camera:t,domElement:r,intersectObjects:s,touch:i=!0,resetOnEnd:l=!1,resetPosition:m=new h(0,0),resetPositionV3:u=new a(0,0,0),onEnter:c=(()=>{}),onMove:p=(()=>{}),onLeave:f=(()=>{}),onIntersectEnter:g=(()=>{}),onIntersectOver:y=(()=>{}),onIntersectMove:b=(()=>{}),onIntersectLeave:v=(()=>{}),onIntersectClick:S=(()=>{})}=e,x=m.clone(),w=new h(0,0),P=function(e){const{camera:t,resetPosition:r=new a(0,0,0)}=e,s=new n,i=r.clone(),h=new o(new a(0,0,1),0);return{position:i,updatePosition:e=>{s.setFromCamera(e,t),t.getWorldDirection(h.normal),s.ray.intersectPlane(h,i)},intersect:(e,r)=>(s.setFromCamera(e,t),s.intersectObjects(r))}}({camera:t}),N=P.position,M={position:x,positionN:w,positionV3:N,intersectObjects:s,listeners:!1,addListeners:function(){r.addEventListener("mouseenter",_),r.addEventListener("mousemove",j),r.addEventListener("mouseleave",z),r.addEventListener("click",k),i&&(r.addEventListener("touchstart",_),r.addEventListener("touchmove",j),r.addEventListener("touchend",z));M.listeners=!0},removeListeners:function(){r.removeEventListener("mouseenter",_),r.removeEventListener("mousemove",j),r.removeEventListener("mouseleave",z),r.removeEventListener("click",k),r.removeEventListener("touchstart",_),r.removeEventListener("touchmove",j),r.removeEventListener("touchend",z),M.listeners=!1},intersect:L};return M;function C(e){let t,s;e.touches&&e.touches.length>0?(t=e.touches[0].clientX,s=e.touches[0].clientY):(t=e.clientX,s=e.clientY);const i=r.getBoundingClientRect();x.x=t-i.left,x.y=s-i.top,w.x=x.x/i.width*2-1,w.y=-x.y/i.height*2+1,P.updatePosition(w)}function L(){if(s.length){const e=P.intersect(w,s),t=[...s],r=[];e.forEach((e=>{const{object:s}=e,{component:i}=s;if(s instanceof d){if(-1!==r.indexOf(s))return;r.push(s)}if(!s.over){s.over=!0;const t={type:"pointerover",over:!0,component:i,intersect:e},r={...t,type:"pointerenter"};y(t),g(r),i.onPointerOver?.(t),i.onPointerEnter?.(r)}const a={type:"pointermove",component:i,intersect:e};b(a),i.onPointerMove?.(a),t.splice(t.indexOf(s),1)})),t.forEach((e=>{const{component:t}=e;if(e.over){e.over=!1;const r={type:"pointerover",over:!1,component:t},s={...r,type:"pointerleave"};y(r),v(s),t.onPointerOver?.(r),t.onPointerLeave?.(s)}}))}}function _(e){C(e),c({type:"pointerenter",position:x,positionN:w,positionV3:N})}function j(e){C(e),p({type:"pointermove",position:x,positionN:w,positionV3:N}),L()}function k(e){if(C(e),s.length){const e=P.intersect(w,s),t=[];e.forEach((e=>{const{object:r}=e,{component:s}=r;if(r instanceof d){if(-1!==t.indexOf(r))return;t.push(r)}const i={type:"click",component:s,intersect:e};S(i),s.onClick?.(i)}))}}function z(){l&&(x.copy(m),N.copy(u)),f({type:"pointerleave"})}}function Le(){const e={canvas:null,antialias:!0,alpha:!1,autoClear:!0,orbit_ctrl:!1,pointer:!1,resize:!1,width:300,height:150},t={width:1,height:1,wWidth:1,wHeight:1,ratio:1},r=[];let s=[],i=[];const a=[],n={conf:e,renderer:null,camera:null,cameraCtrl:null,scene:null,pointer:null,size:t,init:function(t){t&&Object.entries(t).forEach((([t,r])=>{e[t]=r}));if(!n.scene)return void console.error("Missing Scene");if(!n.camera)return void console.error("Missing Camera");n.renderer=new l({canvas:e.canvas,antialias:e.antialias,alpha:e.alpha}),n.renderer.autoClear=e.autoClear,e.resize?(h(),window.addEventListener("resize",h)):d(e.width,e.height);o(),e.orbit_ctrl&&(n.orbitCtrl=new me(n.camera,n.renderer.domElement),e.orbit_ctrl instanceof Object&&Object.entries(e.orbit_ctrl).forEach((([e,t])=>{n.orbitCtrl[e]=t})));return r.forEach((e=>e())),!0},dispose:function(){i=[],window.removeEventListener("resize",h),n.pointer&&n.pointer.removeListeners();n.orbitCtrl&&n.orbitCtrl.dispose();n.renderer&&n.renderer.dispose()},render:function(){n.orbitCtrl&&n.orbitCtrl.update();i.forEach((e=>e())),n.renderer.render(n.scene,n.camera)},renderC:function(){n.orbitCtrl&&n.orbitCtrl.update();i.forEach((e=>e())),n.composer.render()},setSize:d,onAfterInit:function(e){r.push(e)},onAfterResize:function(e){s.push(e)},offAfterResize:function(e){s=s.filter((t=>t!==e))},addIntersectObject:function(e){-1===a.indexOf(e)&&a.push(e);n.pointer&&!n.pointer.listeners&&n.pointer.addListeners()},removeIntersectObject:function(t){const r=a.indexOf(t);-1!==r&&a.splice(r,1);n.pointer&&!e.pointer&&0===a.length&&n.pointer.removeListeners()}};function o(){let t={camera:n.camera,domElement:n.renderer.domElement,intersectObjects:a};var r;e.pointer&&e.pointer instanceof Object&&(t={...t,...e.pointer}),n.pointer=Ce(t),(e.pointer||a.length)&&(n.pointer.addListeners(),"frame"===e.pointer.intersectMode&&(r=()=>{n.pointer.intersect()},i.push(r)))}function h(){if("window"===e.resize)d(window.innerWidth,window.innerHeight);else{const e=n.renderer.domElement.parentNode;d(e.clientWidth,e.clientHeight)}s.forEach((e=>e()))}function d(e,r){if(t.width=e,t.height=r,t.ratio=e/r,n.renderer.setSize(e,r,!1),n.camera.aspect=t.ratio,n.camera.updateProjectionMatrix(),n.composer&&n.composer.setSize(e,r),"OrthographicCamera"===n.camera.type)t.wWidth=n.camera.right-n.camera.left,t.wHeight=n.camera.top-n.camera.bottom;else{const e=function(){const e=n.camera.fov*Math.PI/180,t=2*Math.tan(e/2)*Math.abs(n.camera.position.z);return[t*n.camera.aspect,t]}();t.wWidth=e[0],t.wHeight=e[1]}}return n}var _e=e({name:"Renderer",props:{antialias:Boolean,alpha:Boolean,autoClear:{type:Boolean,default:!0},orbitCtrl:{type:[Boolean,Object],default:!1},pointer:{type:[Boolean,Object],default:!1},resize:{type:[Boolean,String],default:!1},shadow:Boolean,width:String,height:String,xr:Boolean},setup:()=>({three:Le(),raf:!0,onMountedCallbacks:[],beforeRenderCallbacks:[],afterRenderCallbacks:[]}),provide(){return{three:this.three,rendererComponent:this}},mounted(){const e={canvas:this.$el,antialias:this.antialias,alpha:this.alpha,autoClear:this.autoClear,orbit_ctrl:this.orbitCtrl,pointer:this.pointer,resize:this.resize,width:this.width,height:this.height};this.three.init(e)&&(this.renderer=this.three.renderer,this.renderer.shadowMap.enabled=this.shadow,this._render=this.three.composer?this.three.renderC:this.three.render,this.xr?(this.renderer.xr.enabled=!0,this.renderer.setAnimationLoop(this.render)):requestAnimationFrame(this.renderLoop)),this.onMountedCallbacks.forEach((e=>e()))},beforeUnmount(){this.beforeRenderCallbacks=[],this.afterRenderCallbacks=[],this.raf=!1,this.three.dispose()},methods:{onMounted(e){this.onMountedCallbacks.push(e)},onBeforeRender(e){this.beforeRenderCallbacks.push(e)},offBeforeRender(e){this.beforeRenderCallbacks=this.beforeRenderCallbacks.filter((t=>t!==e))},onAfterRender(e){this.afterRenderCallbacks.push(e)},offAfterRender(e){this.afterRenderCallbacks=this.afterRenderCallbacks.filter((t=>t!==e))},onAfterResize(e){this.three.onAfterResize(e)},offAfterResize(e){this.three.offAfterResize(e)},render(e){this.beforeRenderCallbacks.forEach((t=>t({time:e}))),this._render(),this.afterRenderCallbacks.forEach((t=>t({time:e})))},renderLoop(e){this.raf&&requestAnimationFrame(this.renderLoop),this.render(e)}},render(){return t("canvas",{},this.$slots.default())},__hmrId:"Renderer"});function je(e,t){t instanceof Object&&Object.entries(t).forEach((([t,r])=>{e[t]=r}))}function ke(e,t,r){t.forEach((t=>{ze(e,t,r)}))}function ze(e,t,i,a){a||(a=t);const n=r(e,t);n.value instanceof Object?(je(i[a],n.value),s(n,(e=>{je(i[a],e)}),{deep:!0})):(n.value&&(i[a]=e[t]),s(n,(e=>{i[a]=e})))}function Ie(e,t){const r={};return Object.entries(e).forEach((([e,s])=>{(!t||t&&!t.includes(e))&&(r[e]=s)})),r}function Oe(e,t,r){return e+(t-e)*(r=(r=r<0?0:r)>1?1:r)}function Ge(e,t,r){e.x=Oe(e.x,t.x,r),e.y=Oe(e.y,t.y,r)}function Ee(e,t,r){e.x=Oe(e.x,t.x,r),e.y=Oe(e.y,t.y,r),e.z=Oe(e.z,t.z,r)}function Re(e,t,r){return e<t?t:e>r?r:e}function Ae(e,t=1024){return`https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d/${t}/${`${e}${function(e){switch(e){case 64:return"-64px";case 128:return"-128px";case 256:return"-256px";case 512:return"-512px";default:return""}}(t)}.png`}`}var Te=e({inject:["three"],render(){return this.$slots.default?this.$slots.default():[]}}),Be=e({extends:Te,name:"OrthographicCamera",inject:["three"],props:{left:{type:Number,default:-1},right:{type:Number,default:1},top:{type:Number,default:1},bottom:{type:Number,default:-1},near:{type:Number,default:.1},far:{type:Number,default:2e3},zoom:{type:Number,default:1},position:{type:Object,default:{x:0,y:0,z:0}}},created(){this.camera=new m(this.left,this.right,this.top,this.bottom,this.near,this.far),ze(this,"position",this.camera),["left","right","top","bottom","near","far","zoom"].forEach((e=>{s((()=>this[e]),(()=>{this.camera[e]=this[e],this.camera.updateProjectionMatrix()}))})),this.three.camera=this.camera},__hmrId:"OrthographicCamera"}),Fe=e({extends:Te,name:"PerspectiveCamera",inject:["three"],props:{aspect:{type:Number,default:1},far:{type:Number,default:2e3},fov:{type:Number,default:50},near:{type:Number,default:.1},position:{type:Object,default:{x:0,y:0,z:0}},lookAt:{type:Object,default:null}},created(){this.camera=new u(this.fov,this.aspect,this.near,this.far),ze(this,"position",this.camera),this.lookAt&&this.camera.lookAt(this.lookAt.x,this.lookAt.y,this.lookAt.z),s((()=>this.lookAt),(e=>{this.camera.lookAt(e.x,e.y,e.z)}),{deep:!0}),["aspect","far","fov","near"].forEach((e=>{s((()=>this[e]),(()=>{this.camera[e]=this[e],this.camera.updateProjectionMatrix()}))})),this.three.camera=this.camera},__hmrId:"PerspectiveCamera"}),De=e({name:"Object3D",inject:["three","scene","rendererComponent"],emits:["created","ready"],props:{position:{type:Object,default:{x:0,y:0,z:0}},rotation:{type:Object,default:{x:0,y:0,z:0}},scale:{type:Object,default:{x:1,y:1,z:1}},lookAt:{type:Object,default:null},autoRemove:{type:Boolean,default:!0},userData:{type:Object,default:()=>({})}},unmounted(){this.autoRemove&&this.removeFromParent()},methods:{initObject3D(e){this.o3d=e,this.o3d.userData=this.userData,this.$emit("created",this.o3d),ze(this,"position",this.o3d),ze(this,"rotation",this.o3d),ze(this,"scale",this.o3d),this.lookAt&&this.o3d.lookAt(this.lookAt.x,this.lookAt.y,this.lookAt.z),s((()=>this.lookAt),(e=>{this.o3d.lookAt(e.x,e.y,e.z)}),{deep:!0}),this._parent=this.getParent(),this.addToParent()?this.$emit("ready",this):console.error("Missing parent (Scene, Group...)")},getParent(){let e=this.$parent;for(;e;){if(e.add)return e;e=e.$parent}return!1},addToParent(e){const t=e||this.o3d;return!!this._parent&&(this._parent.add(t),!0)},removeFromParent(e){const t=e||this.o3d;return!!this._parent&&(this._parent.remove(t),!0)},add(e){this.o3d.add(e)},remove(e){this.o3d.remove(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Object3D"}),Ue=e({name:"Group",extends:De,created(){this.group=new c,this.initObject3D(this.group)},__hmrId:"Group"}),$e=e({name:"Scene",inject:["three"],props:{id:String,background:[String,Number]},setup(e){const t=new p;return e.background&&(t.background=new f(e.background)),s((()=>e.background),(e=>{t.background.set(e)})),{scene:t}},provide(){return{scene:this.scene}},mounted(){this.three.scene||(this.three.scene=this.scene)},methods:{add(e){this.scene.add(e)},remove(e){this.scene.remove(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Scene"}),We=e({name:"Raycaster",inject:["three","rendererComponent"],props:{onPointerEnter:{type:Function,default:()=>{}},onPointerOver:{type:Function,default:()=>{}},onPointerMove:{type:Function,default:()=>{}},onPointerLeave:{type:Function,default:()=>{}},onClick:{type:Function,default:()=>{}},intersectMode:{type:String,default:"move"}},mounted(){this.rendererComponent.onMounted((()=>{this.pointer=Ce({camera:this.three.camera,domElement:this.three.renderer.domElement,intersectObjects:this.getIntersectObjects(),onIntersectEnter:this.onPointerEnter,onIntersectOver:this.onPointerOver,onIntersectMove:this.onPointerMove,onIntersectLeave:this.onPointerLeave,onIntersectClick:this.onClick}),this.pointer.addListeners(),"frame"===this.intersectMode&&this.rendererComponent.onBeforeRender(this.pointer.intersect)}))},unmounted(){this.pointer&&(this.pointer.removeListeners(),this.rendererComponent.offBeforeRender(this.pointer.intersect))},methods:{getIntersectObjects(){return this.three.scene.children.filter((e=>"Mesh"===e.type))}},render:()=>[],__hmrId:"Raycaster"});const He=e({inject:["mesh"],props:{rotateX:Number,rotateY:Number,rotateZ:Number},created(){this.mesh||console.error("Missing parent Mesh"),this.watchProps=[],Object.entries(this.$props).forEach((e=>this.watchProps.push(e[0]))),this.createGeometry(),this.rotateGeometry(),this.mesh.setGeometry(this.geometry),this.addWatchers()},unmounted(){this.geometry.dispose()},methods:{addWatchers(){this.watchProps.forEach((e=>{s((()=>this[e]),(()=>{this.refreshGeometry()}))}))},rotateGeometry(){this.rotateX&&this.geometry.rotateX(this.rotateX),this.rotateY&&this.geometry.rotateY(this.rotateY),this.rotateZ&&this.geometry.rotateZ(this.rotateZ)},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.rotateGeometry(),this.mesh.setGeometry(this.geometry),e.dispose()}},render:()=>[]});function Xe(t,r,s){return e({name:t,extends:He,props:r,methods:{createGeometry(){this.geometry=s(this)}}})}const Ve={size:Number,width:{type:Number,default:1},height:{type:Number,default:1},depth:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},depthSegments:{type:Number,default:1}};function Ke(e){return e.size?new g(e.size,e.size,e.size,e.widthSegments,e.heightSegments,e.depthSegments):new g(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}var Ze=Xe("BoxGeometry",Ve,Ke);const Ye={radius:{type:Number,default:1},segments:{type:Number,default:8},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:2*Math.PI}};function qe(e){return new y(e.radius,e.segments,e.thetaStart,e.thetaLength)}var Je=Xe("CircleGeometry",Ye,qe);const Qe={radius:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:2*Math.PI}};function et(e){return new b(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var tt=Xe("ConeGeometry",Qe,et);const rt={radiusTop:{type:Number,default:1},radiusBottom:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:2*Math.PI}};function st(e){return new v(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var it=Xe("CylinderGeometry",rt,st);const at={radius:{type:Number,default:1},detail:{type:Number,default:0}};function nt(e){return new S(e.radius,e.detail)}var ot=Xe("DodecahedronGeometry",at,nt);const ht={radius:{type:Number,default:1},detail:{type:Number,default:0}};function dt(e){return new x(e.radius,e.detail)}var lt=Xe("IcosahedronGeometry",ht,dt);const mt={points:Array,segments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:2*Math.PI}};function ut(e){return new w(e.points,e.segments,e.phiStart,e.phiLength)}var ct=Xe("LatheGeometry",mt,ut);const pt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function ft(e){return new P(e.radius,e.detail)}var gt=Xe("OctahedronGeometry",pt,ft);const yt={width:{type:Number,default:1},height:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1}};function bt(e){return new N(e.width,e.height,e.widthSegments,e.heightSegments)}var vt=Xe("PlaneGeometry",yt,bt);const St={vertices:Array,indices:Array,radius:{type:Number,default:1},detail:{type:Number,default:0}};function xt(e){return new M(e.vertices,e.indices,e.radius,e.detail)}var wt=Xe("PolyhedronGeometry",St,xt);const Pt={innerRadius:{type:Number,default:.5},outerRadius:{type:Number,default:1},thetaSegments:{type:Number,default:8},phiSegments:{type:Number,default:1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:2*Math.PI}};function Nt(e){return new C(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}var Mt=Xe("RingGeometry",Pt,Nt);const Ct={radius:{type:Number,default:1},widthSegments:{type:Number,default:12},heightSegments:{type:Number,default:12}};function Lt(e){return new L(e.radius,e.widthSegments,e.heightSegments)}var _t=Xe("SphereGeometry",Ct,Lt);const jt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function kt(e){return new _(e.radius,e.detail)}var zt=Xe("TetrahedronGeometry",jt,kt);const It={radius:{type:Number,default:1},tube:{type:Number,default:.4},radialSegments:{type:Number,default:8},tubularSegments:{type:Number,default:6},arc:{type:Number,default:2*Math.PI}};function Ot(e){return new j(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}var Gt=Xe("TorusGeometry",It,Ot);const Et={radius:{type:Number,default:1},tube:{type:Number,default:.4},tubularSegments:{type:Number,default:64},radialSegments:{type:Number,default:8},p:{type:Number,default:2},q:{type:Number,default:3}};function Rt(e){return new k(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}var At=Xe("TorusKnotGeometry",Et,Rt);const Tt={points:Array,path:I,tubularSegments:{type:Number,default:64},radius:{type:Number,default:1},radialSegments:{type:Number,default:8},closed:{type:Boolean,default:!1}};function Bt(e){let t;return e.points?t=new O(e.points):e.path?t=e.path:console.error("Missing path curve or points."),new z(t,e.tubularSegments,e.radius,e.radiusSegments,e.closed)}var Ft=e({extends:He,props:Tt,methods:{createGeometry(){this.geometry=Bt(this)},updatePoints(e){Dt(this.geometry,e)}}});function Dt(e,t){const r=new O(t),{radialSegments:s,radius:i,tubularSegments:n,closed:o}=e.parameters,h=r.computeFrenetFrames(n,o);e.tangents=h.tangents,e.normals=h.normals,e.binormals=h.binormals,e.parameters.path=r;const d=e.attributes.position.array,l=e.attributes.normal.array,m=new a;let u;for(let e=0;e<n;e++)c(e);function c(e){u=r.getPointAt(e/n,u);const t=h.normals[e],a=h.binormals[e];for(let r=0;r<=s;r++){const n=r/s*Math.PI*2,o=Math.sin(n),h=-Math.cos(n);m.x=h*t.x+o*a.x,m.y=h*t.y+o*a.y,m.z=h*t.z+o*a.z,m.normalize();const c=3*(e*(s+1)+r);l[c]=m.x,l[c+1]=m.y,l[c+2]=m.z,d[c]=u.x+i*m.x,d[c+1]=u.y+i*m.y,d[c+2]=u.z+i*m.z}}c(n),e.attributes.position.needsUpdate=!0,e.attributes.normal.needsUpdate=!0}var Ut=e({extends:De,name:"Light",props:{color:{type:String,default:"#ffffff"},intensity:{type:Number,default:1},castShadow:{type:Boolean,default:!1},shadowMapSize:{type:Object,default:{x:512,y:512}},shadowCamera:{type:Object,default:{}}},unmounted(){this.light.target&&this.removeFromParent(this.light.target)},methods:{initLight(){this.light.target&&ze(this,"target",this.light.target,"position"),this.light.shadow&&(this.light.castShadow=this.castShadow,je(this.light.shadow.mapSize,this.shadowMapSize),je(this.light.shadow.camera,this.shadowCamera)),["color","intensity","castShadow"].forEach((e=>{s((()=>this[e]),(()=>{"color"===e?this.light.color.set(this.color):this.light[e]=this[e]}))})),this.initObject3D(this.light),this.light.target&&this.addToParent(this.light.target)}},__hmrId:"Light"}),$t=e({extends:Ut,created(){this.light=new G(this.color,this.intensity),this.initLight()},__hmrId:"AmbientLight"}),Wt=e({extends:Ut,props:{target:Object},created(){this.light=new E(this.color,this.intensity),this.initLight()},__hmrId:"DirectionalLight"}),Ht=e({extends:Ut,props:{groundColor:{type:String,default:"#444444"}},created(){this.light=new R(this.color,this.groundColor,this.intensity),s((()=>this.groundColor),(e=>{this.light.groundColor.set(e)})),this.initLight()},__hmrId:"HemisphereLight"}),Xt=e({extends:Ut,props:{distance:{type:Number,default:0},decay:{type:Number,default:1}},created(){this.light=new A(this.color,this.intensity,this.distance,this.decay),this.initLight()},__hmrId:"PointLight"}),Vt=e({extends:Ut,props:{width:{type:Number,default:10},height:{type:Number,default:10},helper:Boolean},created(){ue.init(),this.light=new T(this.color,this.intensity,this.width,this.height),["width","height"].forEach((e=>{s((()=>this[e]),(()=>{this.light[e]=this[e]}))})),this.helper&&(this.lightHelper=new ce(this.light),this.light.add(this.lightHelper)),this.initLight()},unmounted(){this.lightHelper&&this.removeFromParent(this.lightHelper)},__hmrId:"RectAreaLight"}),Kt=e({extends:Ut,props:{angle:{type:Number,default:Math.PI/3},decay:{type:Number,default:1},distance:{type:Number,default:0},penumbra:{type:Number,default:0},target:Object},created(){this.light=new B(this.color,this.intensity,this.distance,this.angle,this.penumbra,this.decay),["angle","decay","distance","penumbra"].forEach((e=>{s((()=>this[e]),(()=>{this.light[e]=this[e]}))})),this.initLight()},__hmrId:"SpotLight"}),Zt=e({inject:["three","mesh"],props:{color:{type:[String,Number],default:"#ffffff"},depthTest:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!0},fog:{type:Boolean,default:!0},opacity:{type:Number,default:1},side:{type:Number,default:F},transparent:Boolean,vertexColors:Boolean},provide(){return{material:this}},created(){this.createMaterial(),this.mesh.setMaterial(this.material),this._addWatchers(),this.addWatchers&&this.addWatchers()},unmounted(){this.material.dispose()},methods:{setProp(e,t,r=!1){this.material[e]=t,this.material.needsUpdate=r},setTexture(e,t="map"){this.setProp(t,e,!0)},_addWatchers(){["color","depthTest","depthWrite","fog","opacity","side","transparent"].forEach((e=>{s((()=>this[e]),(()=>{"color"===e?this.material.color.set(this.color):this.material[e]=this[e]}))}))}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Material"});const Yt={wireframe:{type:Boolean,default:!1},wireframeLinewidth:{type:Number,default:1}};var qt=e({extends:Zt,props:{...Yt},methods:{createMaterial(){this.material=new D(Ie(this.$props))},addWatchers(){ke(this,Object.keys(Yt),this.material)}},__hmrId:"BasicMaterial"}),Jt=e({extends:Zt,props:{...Yt},methods:{createMaterial(){this.material=new U(Ie(this.$props))},addWatchers(){ke(this,Object.keys(Yt),this.material)}},__hmrId:"LambertMaterial"}),Qt=e({extends:Zt,props:{src:String,name:String,flatShading:Boolean},methods:{createMaterial(){const e=this.name?Ae(this.name):this.src,t=Ie(this.$props,["src","name"]);t.matcap=(new $).load(e),this.material=new W(t)},addWatchers(){}},__hmrId:"MatcapMaterial"}),er=e({extends:Zt,props:{emissive:{type:[Number,String],default:0},emissiveIntensity:{type:Number,default:1},reflectivity:{type:Number,default:1},shininess:{type:Number,default:30},specular:{type:[String,Number],default:1118481},flatShading:Boolean,...Yt},methods:{createMaterial(){this.material=new H(Ie(this.$props))},addWatchers(){["emissive","emissiveIntensity","reflectivity","shininess","specular"].forEach((e=>{s((()=>this[e]),(t=>{"emissive"===e||"specular"===e?this.material[e].set(t):this.material[e]=t}))})),ke(this,Object.keys(Yt),this.material)}},__hmrId:"PhongMaterial"});const tr={aoMapIntensity:{type:Number,default:1},bumpScale:{type:Number,default:1},displacementBias:{type:Number,default:0},displacementScale:{type:Number,default:1},emissive:{type:[Number,String],default:0},emissiveIntensity:{type:Number,default:1},envMapIntensity:{type:Number,default:1},lightMapIntensity:{type:Number,default:1},metalness:{type:Number,default:0},normalScale:{type:Object,default:{x:1,y:1}},roughness:{type:Number,default:1},refractionRatio:{type:Number,default:.98},flatShading:Boolean};var rr=e({extends:Zt,props:{...tr,...Yt},methods:{createMaterial(){this.material=new X(Ie(this.$props,["normalScale"]))},addWatchers(){Object.keys(tr).forEach((e=>{"normalScale"!==e&&s((()=>this[e]),(t=>{"emissive"===e?this.material[e].set(t):this.material[e]=t}))})),ze(this,"normalScale",this.material),ke(this,Object.keys(Yt),this.material)}},__hmrId:"StandardMaterial"}),sr=e({extends:rr,props:{flatShading:Boolean},methods:{createMaterial(){this.material=new V(Ie(this.$props))},addWatchers(){}},__hmrId:"PhysicalMaterial"});var ir=e({inject:["three","mesh"],props:{uniforms:{type:Object,default:()=>({})},vertexShader:{type:String,default:"\nvarying vec2 vUv;\nvoid main(){\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n}"},fragmentShader:{type:String,default:"\nvarying vec2 vUv;\nvoid main() {\n  gl_FragColor = vec4(vUv.x, vUv.y, 0., 1.0);\n}"}},provide(){return{material:this}},created(){this.createMaterial(),["vertexShader","fragmentShader"].forEach((e=>{s((()=>this[e]),(()=>{this.material.dispose(),this.createMaterial()}))}))},unmounted(){this.material.dispose()},methods:{createMaterial(){this.material=new K(Ie(this.$props)),this.mesh.setMaterial(this.material)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"ShaderMaterial"});const ar=Z.meshphong_frag.slice(0,Z.meshphong_frag.indexOf("void main() {")),nr=Z.meshphong_frag.slice(Z.meshphong_frag.indexOf("void main() {")),or={uniforms:Y.merge([q.phong.uniforms,{thicknessColor:{value:new f(16777215)},thicknessDistortion:{value:.1},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}}]),vertexShader:`\n    #define USE_UV\n    ${Z.meshphong_vert}\n  `,fragmentShader:`\n    #define USE_UV\n    #define SUBSURFACE\n\n    ${ar}\n\n    uniform float thicknessPower;\n    uniform float thicknessScale;\n    uniform float thicknessDistortion;\n    uniform float thicknessAmbient;\n    uniform float thicknessAttenuation;\n    uniform vec3 thicknessColor;\n\n    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n      #ifdef USE_COLOR\n        vec3 thickness = vColor * thicknessColor;\n      #else\n        vec3 thickness = thicknessColor;\n      #endif\n      vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n      float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n      vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n      reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n    }\n  `+nr.replace("#include <lights_fragment_begin>",(hr=Z.lights_fragment_begin,dr="RE_Direct( directLight, geometry, material, reflectedLight );",lr="\n        RE_Direct( directLight, geometry, material, reflectedLight );\n        #if defined( SUBSURFACE ) && defined( USE_UV )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      ",hr.split(dr).join(lr)))};var hr,dr,lr,mr=e({inject:["three","mesh"],props:{color:{type:String,default:"#ffffff"},thicknessColor:{type:String,default:"#ffffff"},thicknessDistortion:{type:Number,default:.4},thicknessAmbient:{type:Number,default:.01},thicknessAttenuation:{type:Number,default:.7},thicknessPower:{type:Number,default:2},thicknessScale:{type:Number,default:4},transparent:{type:Boolean,default:!1},opacity:{type:Number,default:1},vertexColors:{type:Boolean,default:!1}},created(){this.createMaterial(),this.mesh.setMaterial(this.material)},unmounted(){this.material.dispose()},methods:{createMaterial(){const e=or,t=Y.clone(e.uniforms);Object.entries(this.$props).forEach((([e,r])=>{let s=e,i=r;["color","thicknessColor"].includes(e)&&("color"===e&&(s="diffuse"),i=new f(r)),["transparent","vertexColors"].includes(e)||(t[s].value=i)})),this.material=new K({...e,uniforms:t,lights:!0,transparent:this.transparent,vertexColors:this.vertexColors})}},render:()=>[],__hmrId:"SubSurfaceMaterial"}),ur=e({extends:Zt,props:{...Yt},methods:{createMaterial(){this.material=new J(Ie(this.$props))},addWatchers(){ke(this,Object.keys(Yt),this.material)}},__hmrId:"ToonMaterial"}),cr=e({inject:["material"],emits:["loaded"],props:{name:{type:String,default:"map"},uniform:{type:String,default:null},src:String,onLoad:Function,onProgress:Function,onError:Function,mapping:{type:Number,default:Q},wrapS:{type:Number,default:ee},wrapT:{type:Number,default:ee},magFilter:{type:Number,default:te},minFilter:{type:Number,default:re},repeat:{type:Object,default:{x:1,y:1}},rotation:{type:Number,default:0},center:{type:Object,default:{x:0,y:0}}},created(){this.refreshTexture(),s((()=>this.src),this.refreshTexture)},unmounted(){this.material&&this.material.setTexture&&this.material.setTexture(null,this.name),this.texture.dispose()},methods:{createTexture(){this.texture=(new $).load(this.src,this.onLoaded,this.onProgress,this.onError);["mapping","wrapS","wrapT","magFilter","minFilter","repeat","rotation","rotation","center"].forEach((e=>{ze(this,e,this.texture)}))},refreshTexture(){if(this.createTexture(),this.material&&this.material.setTexture)this.material.setTexture(this.texture,this.name);else if(this.material&&"ShaderMaterial"===this.material.material.type){if(!this.uniform)return void console.warn('"uniform" prop required to use texture in a shader.');this.material.uniforms[this.uniform]={value:this.texture}}},onLoaded(){this.onLoad&&this.onLoad(),this.$emit("loaded")}},render:()=>[]}),pr=e({inject:["material"],emits:["loaded"],props:{path:String,urls:{type:Array,default:["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]},onLoad:Function,onProgress:Function,onError:Function,name:{type:String,default:"envMap"},refraction:Boolean,refractionRatio:{type:Number,default:.98}},created(){this.refreshTexture(),s((()=>this.path),this.refreshTexture),s((()=>this.urls),this.refreshTexture)},unmounted(){this.material.setTexture(null,this.name),this.texture.dispose()},methods:{createTexture(){this.texture=(new se).setPath(this.path).load(this.urls,this.onLoaded,this.onProgress,this.onError)},refreshTexture(){this.createTexture(),this.material.setTexture(this.texture,this.name),this.refraction&&(this.texture.mapping=ie,this.material.setProp("refractionRatio",this.refractionRatio))},onLoaded(){this.onLoad&&this.onLoad(),this.$emit("loaded")}},render:()=>[]});const fr={onPointerEnter:Function,onPointerOver:Function,onPointerMove:Function,onPointerLeave:Function,onPointerDown:Function,onPointerUp:Function,onClick:Function},gr=e({name:"Mesh",extends:De,props:{castShadow:Boolean,receiveShadow:Boolean,...fr},provide(){return{mesh:this}},mounted(){this.mesh||this.loading||this.initMesh()},methods:{initMesh(){this.mesh=new ae(this.geometry,this.material),this.mesh.component=this,ze(this,"castShadow",this.mesh),ze(this,"receiveShadow",this.mesh),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.three.addIntersectObject(this.mesh),this.initObject3D(this.mesh)},addGeometryWatchers(e){Object.keys(e).forEach((e=>{s((()=>this[e]),(()=>{this.refreshGeometry()}))}))},setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.mesh.geometry=this.geometry,e.dispose()}},unmounted(){this.mesh&&this.three.removeIntersectObject(this.mesh),this.geometry&&this.geometry.dispose()},__hmrId:"Mesh"});function yr(t,r,s){return e({name:t,extends:gr,props:r,created(){this.createGeometry(),this.addGeometryWatchers(r)},methods:{createGeometry(){this.geometry=s(this)}},__hmrId:t})}var br=yr("Box",Ve,Ke),vr=yr("Circle",Ye,qe),Sr=yr("Cone",Qe,et),xr=yr("Cylinder",rt,st),wr=yr("Dodecahedron",at,nt),Pr=yr("Icosahedron",ht,dt),Nr=yr("Lathe",mt,ut),Mr=yr("Octahedron",pt,ft),Cr=yr("Plane",yt,bt),Lr=yr("Polyhedron",St,xt),_r=yr("Ring",Pt,Nt),jr=yr("Sphere",Ct,Lt),kr=yr("Tetrahedron",jt,kt);const zr={text:String,fontSrc:String,size:{type:Number,default:80},height:{type:Number,default:5},depth:{type:Number,default:1},curveSegments:{type:Number,default:12},bevelEnabled:{type:Boolean,default:!1},bevelThickness:{type:Number,default:10},bevelSize:{type:Number,default:8},bevelOffset:{type:Number,default:0},bevelSegments:{type:Number,default:5},align:{type:[Boolean,String],default:!1}};var Ir=e({extends:gr,props:zr,data:()=>({loading:!0}),created(){["text","size","height","curveSegments","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","align"].forEach((e=>{s((()=>this[e]),(()=>{this.font&&this.refreshGeometry()}))}));(new ne).load(this.fontSrc,(e=>{this.loading=!1,this.font=e,this.createGeometry(),this.initMesh()}))},methods:{createGeometry(){this.geometry=new oe(this.text,{font:this.font,size:this.size,height:this.height,depth:this.depth,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize,bevelOffset:this.bevelOffset,bevelSegments:this.bevelSegments}),"center"===this.align&&this.geometry.center()}}}),Or=yr("Torus",It,Ot),Gr=yr("TorusKnot",Et,Rt),Er=e({extends:gr,props:Tt,created(){this.createGeometry(),this.addGeometryWatchers(Tt)},methods:{createGeometry(){this.geometry=Bt(this)},updatePoints(e){Dt(this.geometry,e)}},__hmrId:"Tube"}),Rr=e({emits:["loaded"],extends:gr,props:{src:String,width:Number,height:Number,keepSize:Boolean},created(){this.createGeometry(),this.createMaterial(),this.initMesh(),s((()=>this.src),this.refreshTexture),["width","height"].forEach((e=>{s((()=>this[e]),this.resize)})),this.keepSize&&this.three.onAfterResize(this.resize)},methods:{createGeometry(){this.geometry=new N(1,1,1,1)},createMaterial(){this.material=new D({side:he,map:this.loadTexture()})},loadTexture(){return(new $).load(this.src,this.onLoaded)},refreshTexture(){this.texture&&this.texture.dispose(),this.material.map=this.loadTexture(),this.material.needsUpdate=!0},onLoaded(e){this.texture=e,this.resize(),this.$emit("loaded")},resize(){if(!this.texture)return;const e=this.three.size,t=this.texture.image.width/this.texture.image.height;let r,s;this.width&&this.height?(r=this.width*e.wWidth/e.width,s=this.height*e.wHeight/e.height):this.width?(r=this.width*e.wWidth/e.width,s=r/t):this.height&&(s=this.height*e.wHeight/e.height,r=s*t),this.mesh.scale.x=r,this.mesh.scale.y=s}},__hmrId:"Image"}),Ar=e({extends:De,props:{castShadow:Boolean,receiveShadow:Boolean,count:Number,...fr},provide(){return{mesh:this}},beforeMount(){this.$slots.default||console.error("Missing Geometry")},mounted(){this.initMesh()},methods:{initMesh(){this.mesh=new d(this.geometry,this.material,this.count),this.mesh.component=this,ze(this,"castShadow",this.mesh),ze(this,"receiveShadow",this.mesh),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.three.addIntersectObject(this.mesh),this.initObject3D(this.mesh)},setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.material.instancingColor=!0,this.mesh&&(this.mesh.material=e)}},unmounted(){this.mesh&&this.three.removeIntersectObject(this.mesh)},__hmrId:"InstancedMesh"}),Tr=e({extends:De,emits:["loaded"],props:{src:String},data:()=>({loading:!0}),created(){this.texture=(new $).load(this.src,this.onLoaded),this.material=new de({map:this.texture}),this.sprite=new le(this.material),this.geometry=this.sprite.geometry,this.initObject3D(this.sprite)},unmounted(){this.texture.dispose(),this.material.dispose()},methods:{onLoaded(){this.loading=!1,this.updateUV(),this.$emit("loaded")},updateUV(){this.iWidth=this.texture.image.width,this.iHeight=this.texture.image.height,this.iRatio=this.iWidth/this.iHeight;let e=.5,t=.5;this.iRatio>1?t=.5/this.iRatio:e=.5/this.iRatio;const r=this.geometry.attributes.position.array;r[0]=-e,r[1]=-t,r[5]=e,r[6]=-t,r[10]=e,r[11]=t,r[15]=-e,r[16]=t,this.geometry.attributes.position.needsUpdate=!0}},__hmrId:"Sprite"}),Br=e({extends:De,emits:["load","progress","error"],data:()=>({progress:0}),methods:{onLoad(e){this.$emit("load",e),this.initObject3D(e)},onProgress(e){this.progress=e.loaded/e.total,this.$emit("progress",e)},onError(e){this.$emit("error",e)}}}),Fr=e({extends:Br,props:{src:String},created(){(new pe).load(this.src,(e=>{this.onLoad(e.scene)}),this.onProgress,this.onError)}}),Dr=e({extends:Br,props:{src:String},created(){(new fe).load(this.src,(e=>{this.onLoad(e)}),this.onProgress,this.onError)}}),Ur=e({setup:()=>({passes:[]}),inject:["three"],provide(){return{passes:this.passes}},mounted(){this.three.onAfterInit((()=>{this.composer=new ge(this.three.renderer),this.three.renderer.autoClear=!1,this.passes.forEach((e=>{this.composer.addPass(e)})),this.three.composer=this.composer,this.resize(),this.three.onAfterResize(this.resize)}))},unmounted(){this.three.offAfterResize(this.resize)},methods:{resize(){this.composer.setSize(this.three.size.width,this.three.size.height)}},render(){return this.$slots.default()},__hmrId:"EffectComposer"}),$r=e({inject:["three","passes"],emits:["ready"],beforeMount(){this.passes||console.error("Missing parent EffectComposer")},unmounted(){this.pass.dispose&&this.pass.dispose()},methods:{completePass(e){this.passes.push(e),this.pass=e,this.$emit("ready",e)}},render:()=>[],__hmrId:"EffectPass"}),Wr=e({extends:$r,mounted(){this.three.scene||console.error("Missing Scene"),this.three.camera||console.error("Missing Camera");const e=new ye(this.three.scene,this.three.camera);this.completePass(e)},__hmrId:"RenderPass"}),Hr=e({extends:$r,props:{focus:{type:Number,default:1},aperture:{type:Number,default:.025},maxblur:{type:Number,default:.01}},watch:{focus(){this.pass.uniforms.focus.value=this.focus},aperture(){this.pass.uniforms.aperture.value=this.aperture},maxblur(){this.pass.uniforms.maxblur.value=this.maxblur}},mounted(){this.three.scene||console.error("Missing Scene"),this.three.camera||console.error("Missing Camera");const e={focus:this.focus,aperture:this.aperture,maxblur:this.maxblur,width:this.three.size.width,height:this.three.size.height},t=new be(this.three.scene,this.three.camera,e);this.completePass(t)},__hmrId:"BokehPass"}),Xr=e({extends:$r,props:{noiseIntensity:{type:Number,default:.5},scanlinesIntensity:{type:Number,default:.05},scanlinesCount:{type:Number,default:4096},grayscale:{type:Number,default:0}},watch:{noiseIntensity(){this.pass.uniforms.nIntensity.value=this.noiseIntensity},scanlinesIntensity(){this.pass.uniforms.sIntensity.value=this.scanlinesIntensity},scanlinesCount(){this.pass.uniforms.sCount.value=this.scanlinesCount},grayscale(){this.pass.uniforms.grayscale.value=this.grayscale}},mounted(){const e=new ve(this.noiseIntensity,this.scanlinesIntensity,this.scanlinesCount,this.grayscale);this.completePass(e)},__hmrId:"FilmPass"}),Vr=e({extends:$r,mounted(){const e=new Se(xe);this.completePass(e),this.three.onAfterResize(this.resize)},unmounted(){this.three.offAfterResize(this.resize)},methods:{resize(){const{resolution:e}=this.pass.material.uniforms;e.value.x=1/this.three.size.width,e.value.y=1/this.three.size.height}},__hmrId:"FXAAPass"}),Kr=e({extends:$r,props:{shape:{type:Number,default:1},radius:{type:Number,default:4},rotateR:{type:Number,default:Math.PI/12*1},rotateG:{type:Number,default:Math.PI/12*2},rotateB:{type:Number,default:Math.PI/12*3},scatter:{type:Number,default:0}},mounted(){const e=new we(this.three.size.width,this.three.size.height,{});["shape","radius","rotateR","rotateG","rotateB","scatter"].forEach((t=>{e.uniforms[t].value=this[t],s((()=>this[t]),(()=>{e.uniforms[t].value=this[t]}))})),this.completePass(e)},__hmrId:"HalftonePass"}),Zr=e({extends:$r,mounted(){const e=new Pe(this.three.size.width,this.three.size.height);this.completePass(e)},__hmrId:"SMAAPass"}),Yr=e({extends:$r,props:{scene:null,camera:null,options:{type:Object,default:()=>({})}},mounted(){const e=new Ne(this.scene||this.three.scene,this.camera||this.three.camera,this.three.size.width,this.three.size.height);for(const t of Object.keys(this.options))e[t]=this.options[t];this.completePass(e)},__hmrId:"SSAOPass"}),qr={uniforms:{},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n    void main() {\n      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n  "},Jr={uniforms:{tDiffuse:{value:null},blurRadius:{value:0},gradientRadius:{value:0},start:{value:new h},end:{value:new h},delta:{value:new h},texSize:{value:new h}},vertexShader:qr.vertexShader,fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform float blurRadius;\n    uniform float gradientRadius;\n    uniform vec2 start;\n    uniform vec2 end;\n    uniform vec2 delta;\n    uniform vec2 texSize;\n    varying vec2 vUv;\n\n    float random(vec3 scale, float seed) {\n      /* use the fragment position for a different seed per-pixel */\n      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n\n    void main() {\n      vec4 color = vec4(0.0);\n      float total = 0.0;\n\n      /* randomize the lookup values to hide the fixed number of samples */\n      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n      vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n      float radius = smoothstep(0.0, 1.0, abs(dot(vUv * texSize - start, normal)) / gradientRadius) * blurRadius;\n      for (float t = -30.0; t <= 30.0; t++) {\n          float percent = (t + offset - 0.5) / 30.0;\n          float weight = 1.0 - abs(percent);\n          vec4 texel = texture2D(tDiffuse, vUv + delta / texSize * percent * radius);\n          // vec4 texel2 = texture2D(tDiffuse, vUv + vec2(-delta.y, delta.x) / texSize * percent * radius);\n\n          /* switch to pre-multiplied alpha to correctly blur transparent images */\n          texel.rgb *= texel.a;\n          // texel2.rgb *= texel2.a;\n\n          color += texel * weight;\n          total += 2.0 * weight;\n      }\n\n      gl_FragColor = color / total;\n\n      /* switch back from pre-multiplied alpha */\n      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n    }\n  "},Qr=e({extends:$r,props:{blurRadius:{type:Number,default:10},gradientRadius:{type:Number,default:100},start:{type:Object,default:{x:0,y:100}},end:{type:Object,default:{x:10,y:100}}},mounted(){this.pass=new Se(Jr),this.passes.push(this.pass),this.pass1=new Se(Jr),this.passes.push(this.pass1);const e=this.uniforms=this.pass.uniforms,t=this.uniforms1=this.pass1.uniforms;t.blurRadius=e.blurRadius,t.gradientRadius=e.gradientRadius,t.start=e.start,t.end=e.end,t.texSize=e.texSize,ze(this,"blurRadius",e.blurRadius,"value"),ze(this,"gradientRadius",e.gradientRadius,"value"),this.updateFocusLine(),["start","end"].forEach((e=>{s((()=>this[e]),this.updateFocusLine,{deep:!0})})),this.pass.setSize=(t,r)=>{e.texSize.value.set(t,r)},this.$emit("ready",[this.pass,this.pass1])},methods:{updateFocusLine(){this.uniforms.start.value.copy(this.start),this.uniforms.end.value.copy(this.end);const e=(new h).copy(this.end).sub(this.start).normalize();this.uniforms.delta.value.copy(e),this.uniforms1.delta.value.set(-e.y,e.x)}},__hmrId:"TiltShiftPass"}),es=e({extends:$r,props:{strength:{type:Number,default:1.5},radius:{type:Number,default:0},threshold:{type:Number,default:0}},watch:{strength(){this.pass.strength=this.strength},radius(){this.pass.radius=this.radius},threshold(){this.pass.threshold=this.threshold}},mounted(){const e=new h(this.three.size.width,this.three.size.height),t=new Me(e,this.strength,this.radius,this.threshold);this.completePass(t)},__hmrId:"UnrealBloomPass"}),ts={uniforms:{tDiffuse:{value:null},center:{value:new h(.5,.5)},strength:{value:0}},vertexShader:qr.vertexShader,fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform vec2 center;\n    uniform float strength;\n    varying vec2 vUv;\n\n    float random(vec3 scale, float seed) {\n      /* use the fragment position for a different seed per-pixel */\n      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n    \n    void main() {\n      vec4 color = vec4(0.0);\n      float total = 0.0;\n      vec2 toCenter = center - vUv;\n      \n      /* randomize the lookup values to hide the fixed number of samples */\n      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n      \n      for (float t = 0.0; t <= 40.0; t++) {\n        float percent = (t + offset) / 40.0;\n        float weight = 4.0 * (percent - percent * percent);\n        vec4 texel = texture2D(tDiffuse, vUv + toCenter * percent * strength);\n\n        /* switch to pre-multiplied alpha to correctly blur transparent images */\n        texel.rgb *= texel.a;\n\n        color += texel * weight;\n        total += weight;\n      }\n\n      gl_FragColor = color / total;\n\n      /* switch back from pre-multiplied alpha */\n      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n    }\n  "},rs=e({extends:$r,props:{center:{type:Object,default:{x:.5,y:.5}},strength:{type:Number,default:.5}},mounted(){const e=new Se(ts),t=this.uniforms=e.uniforms;ze(this,"center",t.center,"value"),ze(this,"strength",t.strength,"value"),this.completePass(e)},__hmrId:"ZoomBlurPass"}),ss=Object.freeze({__proto__:null,Renderer:_e,OrthographicCamera:Be,PerspectiveCamera:Fe,Camera:Fe,Group:Ue,Scene:$e,Object3D:De,Raycaster:We,BoxGeometry:Ze,CircleGeometry:Je,ConeGeometry:tt,CylinderGeometry:it,DodecahedronGeometry:ot,IcosahedronGeometry:lt,LatheGeometry:ct,OctahedronGeometry:gt,PlaneGeometry:vt,PolyhedronGeometry:wt,RingGeometry:Mt,SphereGeometry:_t,TetrahedronGeometry:zt,TorusGeometry:Gt,TorusKnotGeometry:At,TubeGeometry:Ft,AmbientLight:$t,DirectionalLight:Wt,HemisphereLight:Ht,PointLight:Xt,RectAreaLight:Vt,SpotLight:Kt,BasicMaterial:qt,LambertMaterial:Jt,MatcapMaterial:Qt,PhongMaterial:er,PhysicalMaterial:sr,ShaderMaterial:ir,StandardMaterial:rr,SubSurfaceMaterial:mr,ToonMaterial:ur,Texture:cr,CubeTexture:pr,Mesh:gr,Box:br,Circle:vr,Cone:Sr,Cylinder:xr,Dodecahedron:wr,Icosahedron:Pr,Lathe:Nr,Octahedron:Mr,Plane:Cr,Polyhedron:Lr,Ring:_r,Sphere:jr,Tetrahedron:kr,Text:Ir,Torus:Or,TorusKnot:Gr,Tube:Er,Image:Rr,InstancedMesh:Ar,Sprite:Tr,GLTFModel:Fr,FBXModel:Dr,EffectComposer:Ur,RenderPass:Wr,BokehPass:Hr,FilmPass:Xr,FXAAPass:Vr,HalftonePass:Kr,SMAAPass:Zr,SSAOPass:Yr,TiltShiftPass:Qr,UnrealBloomPass:es,ZoomBlurPass:rs,setFromProp:je,bindProps:ke,bindProp:ze,propsValues:Ie,lerp:Oe,lerpv2:Ge,lerpv3:Ee,limit:Re,getMatcapUrl:Ae});const is={install:e=>{["Camera","OrthographicCamera","PerspectiveCamera","Raycaster","Renderer","Scene","Group","AmbientLight","DirectionalLight","HemisphereLight","PointLight","RectAreaLight","SpotLight","BasicMaterial","LambertMaterial","MatcapMaterial","PhongMaterial","PhysicalMaterial","ShaderMaterial","StandardMaterial","SubSurfaceMaterial","ToonMaterial","Texture","CubeTexture","Mesh","Box","BoxGeometry","Circle","CircleGeometry","Cone","ConeGeometry","Cylinder","CylinderGeometry","Dodecahedron","DodecahedronGeometry","Icosahedron","IcosahedronGeometry","Lathe","LatheGeometry","Octahedron","OctahedronGeometry","Plane","PlaneGeometry","Polyhedron","PolyhedronGeometry","Ring","RingGeometry","Sphere","SphereGeometry","Tetrahedron","TetrahedronGeometry","Text","Torus","TorusGeometry","TorusKnot","TorusKnotGeometry","Tube","TubeGeometry","Image","InstancedMesh","Sprite","FBXModel","GLTFModel","BokehPass","EffectComposer","FilmPass","FXAAPass","HalftonePass","RenderPass","SAOPass","SMAAPass","SSAOPass","TiltShiftPass","UnrealBloomPass","ZoomBlurPass","GLTFViewer"].forEach((t=>{e.component(t,ss[t])}))}};function as(e){return i(e).use(is)}export{$t as AmbientLight,qt as BasicMaterial,Hr as BokehPass,br as Box,Ze as BoxGeometry,Fe as Camera,vr as Circle,Je as CircleGeometry,Sr as Cone,tt as ConeGeometry,pr as CubeTexture,xr as Cylinder,it as CylinderGeometry,Wt as DirectionalLight,wr as Dodecahedron,ot as DodecahedronGeometry,Ur as EffectComposer,Dr as FBXModel,Vr as FXAAPass,Xr as FilmPass,Fr as GLTFModel,Ue as Group,Kr as HalftonePass,Ht as HemisphereLight,Pr as Icosahedron,lt as IcosahedronGeometry,Rr as Image,Ar as InstancedMesh,Jt as LambertMaterial,Nr as Lathe,ct as LatheGeometry,Qt as MatcapMaterial,gr as Mesh,De as Object3D,Mr as Octahedron,gt as OctahedronGeometry,Be as OrthographicCamera,Fe as PerspectiveCamera,er as PhongMaterial,sr as PhysicalMaterial,Cr as Plane,vt as PlaneGeometry,Xt as PointLight,Lr as Polyhedron,wt as PolyhedronGeometry,We as Raycaster,Vt as RectAreaLight,Wr as RenderPass,_e as Renderer,_r as Ring,Mt as RingGeometry,Zr as SMAAPass,Yr as SSAOPass,$e as Scene,ir as ShaderMaterial,jr as Sphere,_t as SphereGeometry,Kt as SpotLight,Tr as Sprite,rr as StandardMaterial,mr as SubSurfaceMaterial,kr as Tetrahedron,zt as TetrahedronGeometry,Ir as Text,cr as Texture,Qr as TiltShiftPass,ur as ToonMaterial,Or as Torus,Gt as TorusGeometry,Gr as TorusKnot,At as TorusKnotGeometry,is as TroisJSVuePlugin,Er as Tube,Ft as TubeGeometry,es as UnrealBloomPass,rs as ZoomBlurPass,ze as bindProp,ke as bindProps,as as createApp,Ae as getMatcapUrl,Oe as lerp,Ge as lerpv2,Ee as lerpv3,Re as limit,Ie as propsValues,je as setFromProp};
//# sourceMappingURL=trois.module.cdn.min.js.map
